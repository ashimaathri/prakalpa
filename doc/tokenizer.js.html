<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Prakalpa Source: tokenizer.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Prakalpa</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="prakalpa.parser.DFA.html">prakalpa.parser.DFA</a></li><li><a href="prakalpa.token.html">prakalpa.token</a></li><li><a href="prakalpa.Tokenizer.html">prakalpa.Tokenizer</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#constructor">constructor</a></li><li><a href="global.html#peek">peek</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: tokenizer.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/*
 * This is a port of cpython's tokenizer, Parser/tokenizer.c,
 * in particular, the tok_get function.
 */
define([
  'dojo/_base/declare',
  'dojo/_base/lang',
  'prakalpa/constants/tokens',
  'prakalpa/constants/errors',
  'prakalpa/exceptions',
  'prakalpa/token'
], function (declare, lang, Tokens, Errors, Exceptions, Token) {
  var MAXINDENT;

  MAXINDENT = 100;

  /**
    * The tokenizer splits a string into Python tokens
    * @class prakalpa.Tokenizer
    * @param opts 
    * @param {String} opts.sourceText - Source that needs to be tokenized
    */
  return declare([], /** @lends prakalpa.Tokenizer.prototype */{
    constructor: function (opts) {
      lang.mixin(this, opts);
      this.atBeginningOfLine = true;
      this.level = 0; // Parenthesis nesting level
      this.indstack = [0];
      this.indent = 0;
      this.pending = 0;
      this.charIndex = -1;
      this.startOfToken = {};
      this.contLine = false;
      this.lineNum = 1;
      this.colNum = -1;
      this.lines = this.sourceText.split('\n');
    },

    /**
      * Entrypoint into the tokenizer. Returns the next token in the stream
      * @public
      * @returns {prakalpa.Token} token - Next token 
      * @throws {prakalpa.Exceptions.TokenizeError} Will throw an error if a syntax errors is encountered
      */
    getNext: function () {
      return this._nextline();
    },

    /**
      * Returns the value of the token starting at position {start} and ending
      * just before position {end} both columnwise and linewise
      * @private
      * @param {Object} start - The position at which the token starts
      * @param {Number} start.column - The column number in a line at which the token starts 
      * @param {Number} start.lineNum - The line number in the source at which the token starts 
      * @param {Object} end - The position just before which the token ends
      * @param {Number} end.column - The column number in a line before which the token ends 
      * @param {Number} end.lineNum - The line number in the source before which the token ends
      * @returns {String} tokenString - String value of token starting at start and ending just before end
      */
    _getString: function (start, end) {
      var startLine, endLine, startColumn, endColumn, string, i;

      startColumn = start.column;
      endColumn = end.column;
      startLine = start.lineNum - 1;
      endLine = end.lineNum - 1;

      if(startLine === endLine) {
        string = this.lines[startLine].substring(startColumn, endColumn);
      } else {
        string = this.lines[startLine].substring(startColumn);
        for(i = startLine + 1; i &lt; endLine - 1; i++) {
          string += this.lines[i] + '\n';
        }
        string += this.lines[i].substring(0, endColumn);
      }
      return string;
    },

    /**
      * Get the next character in the stream and keep track of line number and
      * column number
      * @private
      * @returns {String} nextChar - Next character in the source text
      */
    _getNextChar: function () {
      if(this.sourceText[this.charIndex] === '\n') {
        this.lineNum++;
        this.colNum = -1;
      }
      this.charIndex++;
      this.colNum++;
      if(this.charIndex >= this.sourceText.length) { return; }
      return this.sourceText[this.charIndex];
    },

    /**
      * Go back one character in the stream while accounting for newlines
      * @private
      */
    _backupOneChar: function () {
      if(this.charIndex === -1) { return; }
      this.charIndex--;
      this.colNum--;
      if(this.sourceText[this.charIndex] === '\n') {
        this.lineNum--;
      }
    },

    _nextline: function () {
      this.startOfToken = { column: 0, lineNum: this.lineNum };
      this.blankline = false;

      if(this.atBeginningOfLine) {
        this.atBeginningOfLine = false;
        this._countIndentsAndDedents();
      }

      this.startOfToken = { column: this.colNum + 1, lineNum: this.lineNum };

      if(this.pending !== 0) {
        if(this.pending &lt; 0) {
          this.pending++;
          return { type: Tokens.DEDENT, lineNum: this.lineNum };
        } else {
          this.pending--;
          return { type: Tokens.INDENT, lineNum: this.lineNum }; 
        }
      }

      // TODO Add support for async

      return this._again();
    },

    _verifyIdentifier: function () {
      // TODO Add support for Unicode
      return false;
    },

    _processNames: function (c) {
      var nonascii, saw_b, saw_r, saw_u, endOfToken;

      nonascii = false;
      saw_b = saw_r = saw_u = false;

      while(true) {
        if(!(saw_b || saw_u) &amp;&amp; (c === 'b' || c === 'B')) {
          saw_b = true;
        } else if(!(saw_b || saw_u || saw_r) &amp;&amp; (c === 'u' || c === 'U')) {
          saw_u = true;
        } else if(!(saw_r || saw_u) &amp;&amp; (c === 'r' || c === 'R')) {
          saw_r = true;
        } else {
          break;
        }
        c = this._getNextChar();

        if(c === '"' || c === "'") {
          return this._letterQuote(c);
        }
      }

      while (this._isPotentialIdentifierChar(c)) {
        if(c.charCodeAt(0) >= 128) {
          nonascii = true;
        }
        c = this._getNextChar();
      }

      this._backupOneChar();

      if(nonascii &amp;&amp; !this._verifyIdentifier()) {
        throw new Exceptions.TokenizeError({
          message: Errors.TOKEN,
          type: Tokens.ERRORTOKEN,
          lineNum: this.lineNum
        });
      }

      //TODO Add support for async

      endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
      return Token({
        type: Tokens.NAME,
        start: this.startOfToken,
        end: endOfToken,
        string: this._getString(this.startOfToken, endOfToken)
      });
    },

    _again: function () {
      var c, endOfToken;

      //TODO Add support for tabs and form feeds
      do { c = this._getNextChar(); } while (c === ' ');

      this.startOfToken = { column: this.colNum, lineNum: this.lineNum };

      if(c === '#') {
        while (c &amp;&amp; c !== '\n') { c = this._getNextChar(); }
      }

      if(!c) {
        return { type: Tokens.ENDMARKER, lineNum: this.lineNum };
      }

      if(this._isPotentialIdentifierStart(c)) {
        return this._processNames(c);
      }

      if(c === '\n') {
        this.atBeginningOfLine = true;
        if(this.blankline || this.level > 0) { return this._nextline(); }
        this.contLine = false;
        endOfToken = { column: this.colNum, lineNum: this.lineNum };
        return Token({
          type: Tokens.NEWLINE,
          start: this.startOfToken,
          end: endOfToken,
          string: this._getString(this.startOfToken, endOfToken)
        });
      }

      return this._startWithPeriod(c);
    },

    _startWithPeriod: function (c) {
      var endOfToken;

      if(c === '.') {
        c = this._getNextChar();
        if(this._isDigit(c)) {
          return this._fraction();
        } else if(c === '.') {
          c = this._getNextChar();
          if(c === '.') {
            endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
            return Token({
              type: Tokens.ELLIPSIS,
              start: this.startOfToken,
              end: endOfToken,
              string: this._getString(this.startOfToken, endOfToken)
            });
          } else {
            this._backupOneChar();
          }
          this._backupOneChar();
        } else {
          this._backupOneChar();
        }
        endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
        return Token({
          type: Tokens.DOT,
          start: this.startOfToken,
          end: endOfToken,
          string: this._getString(this.startOfToken, endOfToken)
        });
      }

      return this._isNumber(c);
    },

    _isNumber: function (c) {
      var nonZero, charCode, endOfToken;

      if(this._isDigit(c)) {
        if(c === '0') {
          c = this._getNextChar();
          if(c === '.') {
            return this._fraction();
          }
          if(c === 'j' || c === 'J') {
            return this._imaginary();
          }
          if(c === 'x' || c === 'X') {
            c = this._getNextChar();
            if(!this._isXDigit(c)) {
              this._backupOneChar();
              throw new Exceptions.TokenizeError({
                message: Errors.TOKEN,
                type: Tokens.ERRORTOKEN,
                lineNum: this.lineNum
              });
            }
            do {
              c = this._getNextChar();
            } while(this._isXDigit(c));
          } else if(c === 'o' || c === 'O') {
            c = this._getNextChar();
            charCode = c.charCodeAt(0);
            if(charCode &lt; 48 || charCode >= 56) { // Only '0' to '7' are allowed
              this._backupOneChar();
              throw new Exceptions.TokenizeError({
                message: Errors.TOKEN,
                type: Tokens.ERRORTOKEN,
                lineNum: this.lineNum
              });
            }
            do {
              c = this._getNextChar();
            } while (c &amp;&amp; 48 &lt;= c.charCodeAt(0) &amp;&amp; c.charCodeAt(0) &lt; 56);
          } else if(c === 'b' || c === 'B') {
            c = this._getNextChar();
            if(c !== '0' &amp;&amp; c !== '1') {
              this._backupOneChar();
              throw new Exceptions.TokenizeError({
                message: Errors.TOKEN,
                type: Tokens.ERRORTOKEN,
                lineNum: this.lineNum
              });
            }
            do {
              c = this._getNextChar();
            } while (c === '0' || c === '1');
          } else {
            nonZero = false;
            while(c === '0') {
              c = this._getNextChar();
            }
            while(this._isDigit(c)) {
              nonZero = true;
              c = this._getNextChar();
            }
            if(c === '.') {
              return this._fraction();
            } else if(c === 'e' || c === 'E') {
              return this._exponent();
            } else if(c === 'j' || c === 'J') {
              return this._imaginary();
            } else if (nonZero) {
              this._backupOneChar();
              throw new Exceptions.TokenizeError({
                message: Errors.TOKEN,
                type: Tokens.ERRORTOKEN,
                lineNum: this.lineNum
              });
            }
          }
        } else {
          do {
            c = this._getNextChar();
          } while (this._isDigit(c));

          if(c === '.') {
            return this._fraction();
          }

          if(c === 'e' || c === 'E') {
            return this._exponent();
          }

          if(c === 'j' || c === 'J') {
            return this._imaginary();
          }
        }
        this._backupOneChar();
        endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
        return Token({
          type: Tokens.NUMBER,
          start: this.startOfToken,
          end: endOfToken,
          string: this._getString(this.startOfToken, endOfToken)
        });
      }
      return this._letterQuote(c);
    },

    _fraction: function (c) {
      var endOfToken;

      do {
        c = this._getNextChar();
      } while (this._isDigit(c));

      if(c === 'e' || c === 'E') {
        return this._exponent();
      }

      if(c === 'j' || c === 'J') {
        return this._imaginary();
      }

      this._backupOneChar();
      endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
      return Token({
        type: Tokens.NUMBER,
        start: this.startOfToken,
        end: endOfToken,
        string: this._getString(this.startOfToken, endOfToken)
      });
    },

    _exponent: function () {
      var c, endOfToken;

      c = this._getNextChar();
      if(c === '+' || c === '-') {
        c = this._getNextChar();
        if(!this._isDigit(c)) {
          this._backupOneChar();
          throw new Exceptions.TokenizeError({
            message: Errors.TOKEN,
            type: Tokens.ERRORTOKEN,
            lineNum: this.lineNum
          });
        }
      } else if(!this._isDigit(c)) {
        this._backupOneChar();
        this._backupOneChar();
        endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
        return Token({
          type: Tokens.NUMBER,
          start: this.startOfToken,
          end: endOfToken,
          string: this._getString(this.startOfToken, endOfToken)
        });
      }
      do {
        c = this._getNextChar();
      } while(this._isDigit(c));

      if(c === 'j' || c === 'J') {
        return this._imaginary();
      }

      this._backupOneChar();
      endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
      return Token({
        type: Tokens.NUMBER,
        start: this.startOfToken,
        end: endOfToken,
        string: this._getString(this.startOfToken, endOfToken)
      });
    },

    _imaginary: function () {
      var endOfToken;

      endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };

      return Token({
        type: Tokens.NUMBER,
        start: this.startOfToken,
        end: endOfToken,
        string: this._getString(this.startOfToken, endOfToken)
      });
    },

    _letterQuote: function (c) {
      var quote, quoteSize, endQuoteSize, endOfToken;

      if(c === '"' || c === "'") {
        quote = c;
        quoteSize = 1;
        endQuoteSize = 0;

        c = this._getNextChar();
        if(c === quote) {
          c = this._getNextChar();
          if(c === quote) {
            quoteSize = 3;
          } else {
            endQuoteSize = 1;
          }
        }

        if(c !== quote) {
          this._backupOneChar();
        }

        while(endQuoteSize !== quoteSize) {
          c = this._getNextChar();
          if(!c) {
            if(quoteSize === 3) {
              throw new Exceptions.TokenizeError({
                message: Errors.EOFS,
                type: Tokens.ERRORTOKEN,
                lineNum: this.lineNum
              });
            } else {
              throw new Exceptions.TokenizeError({
                message: Errors.EOLS,
                type: Tokens.ERRORTOKEN,
                lineNum: this.lineNum
              });
            }
          }
          if(quoteSize === 1 &amp;&amp; c === '\n') {
            throw new Exceptions.TokenizeError({
              message: Errors.EOLS,
              type: Tokens.ERRORTOKEN,
              lineNum: this.lineNum
            });
          }
          if(c === quote) {
            endQuoteSize += 1;
          } else {
            endQuoteSize = 0;
            if(c === '\\') {
              c = this._getNextChar();
            }
          }
        }

        endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
        return Token({
          type: Tokens.STRING,
          start: this.startOfToken,
          end: endOfToken,
          string: this._getString(this.startOfToken, endOfToken)
        });
      }

      return this._lineContinuation(c);
    },

    _lineContinuation: function (c) {
      if(c === '\\') {
        c = this._getNextChar();
        if(c !== '\n') {
          throw new Exceptions.TokenizeError({
            message: Errors.LINECONT,
            type: Tokens.ERRORTOKEN,
            lineNum: this.lineNum
          });
        }
        this.contLine = true;
        return this._again();
      }

      return this._twoCharacter(c);
    },

    _twoCharacter: function (c) {
      var c2, c3, token, token3, endOfToken;

      c2 = this._getNextChar();
      token = this.twoCharToken(c, c2);
      if(token !== Tokens.OP) {
        c3 = this._getNextChar();
        token3 = this.threeCharToken(c, c2, c3);
        if(token3 !== Tokens.OP) {
          token = token3;
        } else {
          this._backupOneChar();
        }
        endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };
        return Token({
          type: token,
          start: this.startOfToken,
          end: endOfToken,
          string: this._getString(this.startOfToken, endOfToken)
        });
      }
      this._backupOneChar();

      return this._parenthesesCheck(c);
    },

    _parenthesesCheck: function (c) {
      switch(c) {
        case '(':
        case '[':
        case '{':
          this.level++;
          break;
        case ')':
        case ']':
        case '}':
          this.level--;
          break;
      }

      return this._oneCharacter(c);
    },

    _oneCharacter: function (c) {
      var endOfToken;

      endOfToken = { column: this.colNum + 1, lineNum: this.lineNum };

      return Token({
        type: this.oneCharToken(c),
        start: this.startOfToken,
        end: endOfToken,
        string: this._getString(this.startOfToken, endOfToken)
      });
    },

    _isPotentialIdentifierStart: function (c) {
      var code;

      if(typeof(c) === 'undefined') { return false; }
      code = c.charCodeAt(0);

      return ((code > 64 &amp;&amp; code &lt; 91)  || // Uppercase
              (code > 96 &amp;&amp; code &lt; 123) || // Lowercase
              (code >= 128)             || // More than ASCII
              (c === '_'));
    },

    _isPotentialIdentifierChar: function (c) {
      var code;

      if(typeof(c) === 'undefined') { return false; }
      code = c.charCodeAt(0);

      return ((code > 64 &amp;&amp; code &lt; 91)  || // Uppercase
              (code > 96 &amp;&amp; code &lt; 123) || // Lowercase
              (code > 47 &amp;&amp; code &lt; 58)  || // Digit
              (code >= 128)             || // More than ASCII
              (c === '_'));
    },

    _countIndentsAndDedents: function () {
      var col, c;

      col = 0;

      // Supporting only whitespace for now.
      // TODO Add support for tabs and form-feed
      c = this._getNextChar();
      while(c === ' ') {
        col++;
        c = this._getNextChar();
      }

      this._backupOneChar();

      // TODO Add support for interactive mode
      if(c === '\#' || c === '\n') {
        this.blankline = true;
      }

      // I think altcol, altindstack etc. are to check if tabs and spaces
      // are being used inconsistently in indentation.
      // As we don't support tabs anyway, I'm skipping that part of the code
      if(!this.blankline &amp;&amp; this.level === 0) {
        if(col > this.indstack[this.indent]) {
          if(this.indent + 1 >= MAXINDENT) {
            throw new Exceptions.TokenizeError({
              message: Errors.TOODEEP,
              type: Tokens.ERRORTOKEN,
              lineNum: this.lineNum
            });
          }
          this.pending++;
          this.indstack[++this.indent] = col;
        } else if (col &lt; this.indstack[this.indent]) {
          while(this.indent > 0 &amp;&amp; col &lt; this.indstack[this.indent]) {
            this.pending--;
            this.indent--;
          }
          if(col !== this.indstack[this.indent]) {
            throw new Exceptions.TokenizeError({
              message: Errors.DEDENT,
              type: Tokens.ERRORTOKEN,
              lineNum: this.lineNum
            });
          }
        }
      }
    },

    _isDigit: function (c) {
      var charCode;

      if(typeof(c) === 'undefined') { return false; }
      charCode = c.charCodeAt(0);
      return (charCode > 47 &amp;&amp; charCode &lt; 58);
    },

    _isXDigit: function (c) {
      var charCode;

      if(typeof(c) === 'undefined') { return false; }
      charCode = c.charCodeAt(0);
      return (this._isDigit(c) || 
             (charCode >= 65 &amp;&amp; charCode &lt;= 70) || // A to F
             (charCode >= 97 &amp;&amp; charCode &lt;= 102)); // a to f
    },

    /**
      * Returns token corresponding to one character string
      * @public
      * @param {string} c - One character string
      * @returns {prakalpa.constants.Tokens}
      */
    oneCharToken: function (c) {
      switch (c) {
        case '(':           return Tokens.LPAR;
        case ')':           return Tokens.RPAR;
        case '[':           return Tokens.LSQB;
        case ']':           return Tokens.RSQB;
        case ':':           return Tokens.COLON;
        case ',':           return Tokens.COMMA;
        case ';':           return Tokens.SEMI;
        case '+':           return Tokens.PLUS;
        case '-':           return Tokens.MINUS;
        case '*':           return Tokens.STAR;
        case '/':           return Tokens.SLASH;
        case '|':           return Tokens.VBAR;
        case '&amp;':           return Tokens.AMPER;
        case '&lt;':           return Tokens.LESS;
        case '>':           return Tokens.GREATER;
        case '=':           return Tokens.EQUAL;
        case '.':           return Tokens.DOT;
        case '%':           return Tokens.PERCENT;
        case '{':           return Tokens.LBRACE;
        case '}':           return Tokens.RBRACE;
        case '^':           return Tokens.CIRCUMFLEX;
        case '~':           return Tokens.TILDE;
        case '@':           return Tokens.AT;
        default:            return Tokens.OP;
      }
    },

    /**
      * Returns token corresponding to two character string
      * @public
      * @param {string} c1 - First character
      * @param {string} c2 - Second character
      * @returns {prakalpa.constants.Tokens}
      */
    twoCharToken: function (c1, c2) {
      switch (c1) {
        case '=':
          switch (c2) {
            case '=': return Tokens.EQEQUAL;
          }
          break;
        case '!':
          switch (c2) {
            case '=': return Tokens.NOTEQUAL;
          }
          break;
        case '&lt;':
          switch (c2) {
            case '>': return Tokens.NOTEQUAL;
            case '=': return Tokens.LESSEQUAL;
            case '&lt;': return Tokens.LEFTSHIFT;
          }
          break;
        case '>':
          switch (c2) {
            case '=': return Tokens.GREATEREQUAL;
            case '>': return Tokens.RIGHTSHIFT;
          }
          break;
        case '+':
          switch (c2) {
            case '=': return Tokens.PLUSEQUAL;
          }
          break;
        case '-':
          switch (c2) {
            case '=': return Tokens.MINEQUAL;
            case '>': return Tokens.RARROW;
          }
          break;
        case '*':
          switch (c2) {
            case '*': return Tokens.DOUBLESTAR;
            case '=': return Tokens.STAREQUAL;
          }
          break;
        case '/':
          switch (c2) {
            case '/': return Tokens.DOUBLESLASH;
            case '=': return Tokens.SLASHEQUAL;
          }
          break;
        case '|':
          switch (c2) {
            case '=': return Tokens.VBAREQUAL;
          }
          break;
        case '%':
          switch (c2) {
            case '=': return Tokens.PERCENTEQUAL;
          }
          break;
        case '&amp;':
          switch (c2) {
            case '=': return Tokens.AMPEREQUAL;
          }
          break;
        case '^':
          switch (c2) {
            case '=': return Tokens.CIRCUMFLEXEQUAL;
          }
          break;
        case '@':
          switch (c2) {
            case '=': return Tokens.ATEQUAL;
          }
          break;
      }
      return Tokens.OP;
    },

    /**
      * Returns token corresponding to three character string
      * @public
      * @param {string} c1 - First character
      * @param {string} c2 - Second character
      * @param {string} c3 - Third character
      * @returns {prakalpa.constants.Tokens}
      */
    threeCharToken: function (c1, c2, c3) {
      switch (c1) {
        case '&lt;':
          switch (c2) {
            case '&lt;':
              switch (c3) {
                case '=':
                  return Tokens.LEFTSHIFTEQUAL;
              }
              break;
          }
          break;
        case '>':
          switch (c2) {
            case '>':
              switch (c3) {
                case '=':
                  return Tokens.RIGHTSHIFTEQUAL;
              }
              break;
          }
          break;
        case '*':
          switch (c2) {
            case '*':
              switch (c3) {
                case '=':
                  return Tokens.DOUBLESTAREQUAL;
              }
              break;
          }
          break;
        case '/':
          switch (c2) {
            case '/':
              switch (c3) {
                case '=':
                  return Tokens.DOUBLESLASHEQUAL;
              }
              break;
          }
          break;
        case '.':
          switch (c2) {
            case '.':
              switch (c3) {
                case '.':
                  return Tokens.ELLIPSIS;
              }
              break;
          }
          break;
      }
      return Tokens.OP;
    }
  });
});
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright Â© 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.1</a>
	
		on Sun Sep 18th 2016
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
