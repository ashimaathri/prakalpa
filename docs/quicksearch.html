<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"main.js.html":{"id":"main.js.html","title":"Source: main.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: main.js /** * @namespace prakalpa */ define([ 'dojo/_base/declare', 'dojo/_base/lang', 'dojo/query', 'prakalpa/tokenizer', 'prakalpa/parser/meta_grammar', 'prakalpa/parser/main', 'prakalpa/parser/pgen', 'prakalpa/constants/non_terminals', 'dojo/request/xhr', 'dojo/NodeList-manipulate' ], function (declare, lang, query, Tokenizer, metagrammarDFAs, Parser, ParserGenerator, NonTerminals, xhr) { return declare([], { constructor: function (opts) { lang.mixin(this, opts); }, load: function (code, resultEltId) { this.tokenizer = new Tokenizer({ sourceText: code }); this.resultElt = query(resultEltId); this.resultElt.text(''); }, getNextToken: function () { try { this.appendObjectToTextBox(this.tokenizer.getNext()); } catch(e) { this.appendObjectToTextBox(e); } }, appendObjectToTextBox: function (tokenInfo) { var text; text = this.resultElt.text(); text += JSON.stringify(tokenInfo); text += '\\n'; this.resultElt.text(text); }, getAllTokens: function () { var tokenInfo; do { try { tokenInfo = this.tokenizer.getNext(); this.appendObjectToTextBox(tokenInfo); } catch (e) { this.appendObjectToTextBox(e); break; } } while(tokenInfo.type !== 'ENDMARKER'); }, construct_parse_tree: function (pathToGrammarFile, callback) { xhr(pathToGrammarFile) .then(function (pythonGrammar) { callback( new Parser({ grammar: metagrammarDFAs, start: NonTerminals.MSTART, sourceText: pythonGrammar }).parse()); }); }, constructPgen: function (parseTreeRoot) { var pgen; pgen = new ParserGenerator({ parseTreeRoot: parseTreeRoot }); window.labels = pgen.labels; window.dfas= pgen.dfas; } }); }); × Search results Close "},"exceptions.js.html":{"id":"exceptions.js.html","title":"Source: exceptions.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: exceptions.js define(['dojo/_base/lang'], function (lang) { return /** @class prakalpa.Exceptions*/{ /** * @class prakalpa.Exceptions.LeftRecursion * @params {String} message - Error message */ LeftRecursion: function (message) { this.message = message; }, /** * @class prakalpa.Exceptions.TokenizeError * @params {Object} opts */ TokenizeError: function (opts) { lang.mixin(this, opts); }, /** * @class prakalpa.Exceptions.SyntaxError * @params {Object} opts */ ParseError: function (opts) { lang.mixin(this, opts); }, /** * @class prakalpa.Exceptions.AssertionError * @params {Object} opts */ AssertionError: function (opts) { lang.mixin(this, opts); }, /** * A NAME label should either be a Terminal or a NonTerminal * @class prakalpa.Exceptions.InvalidNameLabel * @params {Object} opts * @params {String} opts.type - Type of label * @params {String} opts.string - String value of label */ InvalidNameLabel: function (opts) { lang.mixin(this, opts); }, /** * @class prakalpa.Exceptions.InvalidOneCharLabel * @params {Object} opts * @params {String} opts.type - Type of label * @params {String} opts.string - String value of label */ InvalidOneCharLabel: function (opts) { lang.mixin(this, opts); }, /** * @class prakalpa.Exceptions.InvalidTwoCharLabel * @params {Object} opts * @params {String} opts.type - Type of label * @params {String} opts.string - String value of label */ InvalidTwoCharLabel: function (opts) { lang.mixin(this, opts); }, /** * @class prakalpa.Exceptions.InvalidThreeCharLabel * @params {Object} opts * @params {String} opts.type - Type of label * @params {String} opts.string - String value of label */ InvalidThreeCharLabel: function (opts) { lang.mixin(this, opts); } }; }); × Search results Close "},"utils.js.html":{"id":"utils.js.html","title":"Source: utils.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: utils.js define([ 'dojo/_base/declare', 'prakalpa/constants/tokens', ], function (declare, Tokens) { /** * @module prakalpa.utils */ return { /** * Checks if token is a non-terminal. This method has been added for readability purposes. * @param {String} token - type of token * @param {Object.&lt;String, prakalpa.parser.DFA&gt;} dfas - Map of DFA type to DFA * @returns {Boolean} */ isNonTerminal: function (token, dfas) { return token in dfas; }, /** * Checks if token is a terminal * @param {String} token - type of token * @returns {Boolean} */ isTerminal: function (token) { return token in Tokens; }, /** * Returns token corresponding to one character string * @param {string} c - One character string * @returns {prakalpa.constants.Tokens} Token type */ oneCharToken: function (c) { switch (c) { case '(': return Tokens.LPAR; case ')': return Tokens.RPAR; case '[': return Tokens.LSQB; case ']': return Tokens.RSQB; case ':': return Tokens.COLON; case ',': return Tokens.COMMA; case ';': return Tokens.SEMI; case '+': return Tokens.PLUS; case '-': return Tokens.MINUS; case '*': return Tokens.STAR; case '/': return Tokens.SLASH; case '|': return Tokens.VBAR; case '&amp;': return Tokens.AMPER; case '&lt;': return Tokens.LESS; case '&gt;': return Tokens.GREATER; case '=': return Tokens.EQUAL; case '.': return Tokens.DOT; case '%': return Tokens.PERCENT; case '{': return Tokens.LBRACE; case '}': return Tokens.RBRACE; case '^': return Tokens.CIRCUMFLEX; case '~': return Tokens.TILDE; case '@': return Tokens.AT; default: return Tokens.OP; } }, /** * Returns token corresponding to two character string * @param {string} c1 - First character * @param {string} c2 - Second character * @returns {prakalpa.constants.Tokens} */ twoCharToken: function (c1, c2) { switch (c1) { case '=': switch (c2) { case '=': return Tokens.EQEQUAL; } break; case '!': switch (c2) { case '=': return Tokens.NOTEQUAL; } break; case '&lt;': switch (c2) { case '&gt;': return Tokens.NOTEQUAL; case '=': return Tokens.LESSEQUAL; case '&lt;': return Tokens.LEFTSHIFT; } break; case '&gt;': switch (c2) { case '=': return Tokens.GREATEREQUAL; case '&gt;': return Tokens.RIGHTSHIFT; } break; case '+': switch (c2) { case '=': return Tokens.PLUSEQUAL; } break; case '-': switch (c2) { case '=': return Tokens.MINEQUAL; case '&gt;': return Tokens.RARROW; } break; case '*': switch (c2) { case '*': return Tokens.DOUBLESTAR; case '=': return Tokens.STAREQUAL; } break; case '/': switch (c2) { case '/': return Tokens.DOUBLESLASH; case '=': return Tokens.SLASHEQUAL; } break; case '|': switch (c2) { case '=': return Tokens.VBAREQUAL; } break; case '%': switch (c2) { case '=': return Tokens.PERCENTEQUAL; } break; case '&amp;': switch (c2) { case '=': return Tokens.AMPEREQUAL; } break; case '^': switch (c2) { case '=': return Tokens.CIRCUMFLEXEQUAL; } break; case '@': switch (c2) { case '=': return Tokens.ATEQUAL; } break; } return Tokens.OP; }, /** * Returns token corresponding to three character string * @param {string} c1 - First character * @param {string} c2 - Second character * @param {string} c3 - Third character * @returns {prakalpa.constants.Tokens} */ threeCharToken: function (c1, c2, c3) { switch (c1) { case '&lt;': switch (c2) { case '&lt;': switch (c3) { case '=': return Tokens.LEFTSHIFTEQUAL; } break; } break; case '&gt;': switch (c2) { case '&gt;': switch (c3) { case '=': return Tokens.RIGHTSHIFTEQUAL; } break; } break; case '*': switch (c2) { case '*': switch (c3) { case '=': return Tokens.DOUBLESTAREQUAL; } break; } break; case '/': switch (c2) { case '/': switch (c3) { case '=': return Tokens.DOUBLESLASHEQUAL; } break; } break; case '.': switch (c2) { case '.': switch (c3) { case '.': return Tokens.ELLIPSIS; } break; } break; } return Tokens.OP; } }; }); × Search results Close "},"parser_main.js.html":{"id":"parser_main.js.html","title":"Source: parser/main.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/main.js /* * Port of cpython's parser, Parser/parser.c, * in particular the PyParser_AddToken function. */ /** * @namespace prakalpa.parser */ define([ 'dojo/_base/declare', 'dojo/_base/lang', 'prakalpa/tokenizer', 'prakalpa/parser/stack', 'prakalpa/parser/parse_tree_node', 'prakalpa/constants/status_codes', 'prakalpa/constants/tokens', 'prakalpa/exceptions', ], function (declare, lang, Tokenizer, Stack, ParseTreeNode, ParserStatus, Tokens, Exceptions) { /** * @class prakalpa.parser.Parser * @param {Object} opts * @param {Object.&lt;String, prakalpa.parser.Parser.DFA&gt;} opts.grammar - The grammar containing all the DFAs * @param {String} opts.start - The start symbol of the grammar * @param {String} opts.sourceText - The text that needs to be parsed using this grammar */ return declare([], /** @lends prakalpa.parser.Parser.prototype */{ constructor: function (opts) { var start_dfa, start_state, nonTerminal, dfa; lang.mixin(this, opts); this.tokenizer = new Tokenizer({ sourceText: this.sourceText }); this.parseTreeRoot = new ParseTreeNode({ symbol: this.start, string: null, lineNum: 0, columnOffset: 0 }); start_dfa = this.grammar[this.start]; start_state = start_dfa.states[0]; this.stack = new Stack(); this.stack.push({ dfa: start_dfa, currentParseTreeNode: this.parseTreeRoot, currentState: start_state }); for(nonTerminal in this.grammar) { dfa = this.grammar[nonTerminal]; dfa.constructFollowSet(this.grammar); } }, /** * Entrypoint into the parser. * @returns {prakalpa.parser.ParseTreeNode} parseTreeRoot - The root of the concrete syntax tree */ parse: function () { var token; do { token = this.tokenizer.getNext(); this._addToken(token); } while(token.type !== Tokens.ENDMARKER); return this.parseTreeRoot; }, /** * Adds node to CST and moves current dfa to the next state * Top of the stack will point to the current dfa at the `parserState.nextState` at the end of this method * @private * @param {Object} parserState - Current state of parser * @param {prakalpa.parser.ParseTreeNode} currentParseTreeNode - The concrete syntax tree node which we are processing currently * @returns {prakalpa.parser.ParseTreeNode} childNode - New node added to `currentParseTreeNode` as a child */ _shift: function (parserState, currentParseTreeNode) { var childNode; if(this.stack.isEmpty()) { throw new Error('Stack was not expected to be empty'); } childNode = new ParseTreeNode({ symbol: parserState.symbol, lineNum: parserState.lineNum, string: parserState.string, columnOffset: parserState.columnOffset }); currentParseTreeNode.addChild(childNode); this.stack.updateTop('currentState', parserState.nextState); return childNode; }, /** * Adds node to CST, moves current dfa to next state, pushes current parser state on to the stack and goes to the first state of the new dfa * Top of the stack will point to the new dfa at state 0 at the end of this method. * @private * @param {Object} parserState - Current state of parser * @param {prakalpa.parser.ParseTreeNode} currentParseTreeNode - The concrete syntax tree node which we are processing currently */ _push: function (parserState, currentParseTreeNode) { var childNode; childNode = this._shift(parserState, currentParseTreeNode); this.stack.push({ dfa: parserState.dfa, currentParseTreeNode: childNode, currentState: parserState.dfa.states[0] }); }, /** * Adds a token to the concrete syntax tree using a table driven (`followSet` + `stack`) top-down predictive parsing algorithm. The grammar must be LL(1) for this to work and Python's grammar is [by choice an LL(1) grammar](https://www.python.org/dev/peps/pep-3099/). * @private * @param {Object} parserState - Current state of parser * @param {prakalpa.parser.ParseTreeNode} currentParseTreeNode - The concrete syntax tree node which we are processing currently * @throws {prakalpa.Exceptions.ParseError} If the source does not belong to the language generated by the given grammar */ _addToken: function (token) { var stackEntry, dfa, currentState, currentParseTreeNode, transition, exception; for(;;) { stackEntry = this.stack.peek(); dfa = stackEntry.dfa; currentParseTreeNode = stackEntry.currentParseTreeNode; currentState = stackEntry.currentState; if(token.type in currentState.followSet) { transition = currentState.followSet[token.type]; if(transition.nonTerminal) { this._push({ symbol: transition.nonTerminal, dfa: this.grammar[transition.nonTerminal], nextState: transition.arrow, lineNum: token.start.lineNum }, currentParseTreeNode); continue; } else { this._shift({ symbol: token.type, nextState: transition.arrow, lineNum: token.start.lineNum, string: token.string, columnOffset: token.start.column }, currentParseTreeNode); } currentState = this.stack.peek('currentState'); while(currentState &amp;&amp; currentState.isAccepting &amp;&amp; !currentState.arcs.length) { this.stack.pop(); if(this.stack.isEmpty()) { return; } currentState = this.stack.peek('currentState'); } return; } else if(currentState.isAccepting) { this.stack.pop(); if(this.stack.isEmpty()) { throw new Exceptions.ParseError({ message: 'Stack was not expected to be empty' }); } continue; } else { exception = { message: 'Neither was the token in the follow set of the current DFA state, nor was the current state an accepting state', }; lang.mixin(exception, token); lang.mixin(exception, stackEntry); throw new Exceptions.ParseError(exception); } } } }); }); × Search results Close "},"parser_dfa.js.html":{"id":"parser_dfa.js.html","title":"Source: parser/dfa.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/dfa.js define([ 'dojo/_base/declare', 'dojo/_base/lang', 'dojo/_base/array', 'prakalpa/parser/dfa_state', 'prakalpa/constants/tokens', 'prakalpa/exceptions' ], function (declare, lang, array, DFAState, Terminals, Exceptions) { var START_MARKER; /** * Represents a DFA (deterministic finite automaton) * @class prakalpa.parser.DFA * @param {Object} opts * @param {String} opts.type - NonTerminal constant that represents this DFA * @param {prakalpa.parser.NFA} opts.nfa - The NFA from which the DFA must be constructed * @param [Array&lt;prakalpa.parser.DFAState&gt;] opts.states - The DFA states of this DFA. This only needs to be supplied at parser generation time. Every other time, it is constructed programmatically. * @param [Object.&lt;String, Boolean&gt;] opts.firstSet - A dict (used for fast membership checks) with all the labels of the firstSet as keys. The value doesn't matter. Only needs to be supplied at parser generation time. */ return declare([], /** @lends prakalpa.parser.DFA.prototype */{ constructor: function (opts) { lang.mixin(this, opts); /** * States of the DFA. The first state at index 0 is always the start state. * @name prakalpa.parser.DFA#states * @type {Array&lt;prakalpa.parser.DFAState&gt;} */ this.states = []; this._firstSet = null; if(opts.states &amp;&amp; opts.firstSet) { this.states = opts.states; array.forEach(this.states, function(state) { state.fixReferences(this.states); }.bind(this)); this._firstSet = opts.firstSet; } else { this._start = new DFAState(); this._start.addClosure(this.nfa.start); if(this.nfa.start === this.nfa.end) { this._start.setAsEndState(); } this.states.push(this._start); this._generateDFA(this._start); } }, /** * Generates DFAs recursively, starting at the start state that has already been constructed in the constructor, and visiting the nfa nodes reachable from all the states in the start state * Based on 3.7.1 Conversion of an NFA to a DFA from the [Dragon Book 2nd Edition](http://www.informatik.uni-bremen.de/agbkb/lehre/ccfl/Material/ALSUdragonbook.pdf) * @private * @param {prakalpa.parser.DFAState} state - DFA state to start discovery from */ _generateDFA: function (state) { var label, dfaState; array.forEach(state.nfaStates, function (nfaState) { array.forEach(nfaState, function (arc) { if(arc.label !== Terminals.EMPTY) { state.updateArcDFAState(arc.label, arc.arrow); } }); }); for(label in state.arcs) { dfaState = state.arcs[label]; if(dfaState.containsNFAState(this.nfa.end )) { dfaState.setAsEndState(); } if(this._addState(dfaState)) { this._generateDFA(dfaState); } } }, /** * Adds a DFA state to the list only if not already present. * @private * @param {prakalpa.parser.DFAState} dfaState - DFA state to add to list * @returns {Boolean} newState? - True if new state, false if state is already in the list */ _addState: function (dfaState) { var contains, newState; contains = array.filter(this.states, function (state) { return state.equals(dfaState); }); newState = !contains.length; if(newState) { this.states.push(dfaState); } return newState; }, /** * Calculates the firstSet of this DFA. From the Dragon Book: * &gt; We define `FIRST (a)` to be the set of terminals that appear as the first symbols of one or more strings of terminals generated from `a` * @param {Object.&lt;String, prakalpa.parser.DFA&gt;} dfaGrammar - A map containing all the DFAs for this grammar * @return {Object.&lt;String, Boolean&gt;} firstSet - A dict (used for fast membership checks) with all the labels of the firstSet as keys. The value doesn't matter. * @throws {prakalpa.Exceptions.LeftRecursion} If the grammar is left recursive. */ calcFirstSet: function (dfaGrammar) { var visited, result, label; visited = {}; result = {}; if(this._firstSet === START_MARKER) { throw new Exceptions.LeftRecursion(this.type); } if (this._firstSet) { return this._firstSet; } this._firstSet = START_MARKER; for(label in this._start.arcs) { if(!(label in visited)) { visited[label] = true; if(label in dfaGrammar) { lang.mixin(result, dfaGrammar[label].calcFirstSet(dfaGrammar)); // NonTerminal } else if(label in Terminals){ result[label] = true; // Terminal } } } this._firstSet = result; return this._firstSet; }, /** * Constructs the transition table for each state in this DFA * @param {Object.&lt;String, prakalpa.parser.DFA&gt;} dfaGrammar - A map containing all the DFAs for this grammar */ constructFollowSet: function (dfaGrammar) { array.forEach(this.states, function (state) { state.constructFollowSet(dfaGrammar); }); } }); }); × Search results Close "},"parser_dfa_state.js.html":{"id":"parser_dfa_state.js.html","title":"Source: parser/dfa_state.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/dfa_state.js define([ 'dojo/_base/declare', 'dojo/_base/array', 'prakalpa/constants/tokens', 'prakalpa/constants/non_terminals' ], function (declare, array, Terminals, NonTerminals) { var DFAState; /** * Represents a DFA State * @class prakalpa.parser.DFAState * @param [Object] opts * @param {Array} opts.arcs - Arcs of this DFA State. This is constructed programmatically in all cases except during parser generation where we use the hard-coded metagrammar arcs. * @param {Boolean} opts.isAccepting - Denotes if this state is a final/accepting state. This is usually set using the method `setEndState` but should be provided to the constructor during parser generation. */ DFAState = declare([], /** @lends prakalpa.parser.DFAState.prototype */{ constructor: function (opts) { /** * Array of NFA States * @name prakalpa.parser.DFAState#nfaStates * @type {Array&lt;Object&gt;} */ this.nfaStates = []; /** * Map that has labels(can be Terminals or NonTerminals) as keys and DFA States as values. * @name prakalpa.parser.DFAState#arcs * @type {Object.&lt;String, prakalpa.parser.DFAState&gt;} */ this.arcs = (opts &amp;&amp; opts.arcs) || {}; /** * Map that has Terminal labels as keys and DFA States as values. * @name prakalpa.parser.DFAState#followSet * @type {Object.&lt;String, prakalpa.parser.DFAState&gt;} */ this.followSet = []; /** * Indicates if this DFA state is an accepting state or not * @name prakalpa.parser.DFAState#isAccepting * @type {Boolean} */ this.isAccepting = (opts &amp;&amp; opts.isAccepting) || false; }, /** * Checks if nfaState is absent from list * @private * @param {Object} nfaState * @returns {Boolean} */ _nfaStateAbsent: function (nfaState) { return (this.nfaStates.indexOf(nfaState) === -1); }, /** * Checks if nfaState is present in the list * @param {Object} nfaState * @returns {Boolean} */ containsNFAState: function (nfaState) { return (this.nfaStates.indexOf(nfaState) !== -1); }, /** * Adds nfaState to the list * @param {Object} nfaState */ addNFAState: function (nfaState) { this.nfaStates.push(nfaState); }, /** * Points numbered arrows in the metagrammar into corresponding DFAStates instead * @param {Array&lt;prakalpa.parser.DFAState&gt;} dfaStates - All states of the DFA this state belongs to */ fixReferences: function (dfaStates) { array.forEach(this.arcs, function (arc) { arc.arrow = dfaStates[arc.arrow]; }); }, /** * Mark this DFA state as an end/final/accepting state */ setAsEndState: function () { this.isAccepting = true; }, /** * Add the epsilon closure of the given NFA State to this DFA State * @param {Array} nfaState - An array of arcs */ addClosure: function (nfaState) { if(this._nfaStateAbsent(nfaState)) { this.addNFAState(nfaState); array.forEach(nfaState, function (arc) { if(arc.label === Terminals.EMPTY) { this.addClosure(arc.arrow); } }.bind(this)); } }, /** * Update the DFA State pointed to by the label in the transition table with the epsilon closure of the given NFA State * @param {String} label - The label on the arc * @param {Array} nfaState - Array of arcs in the nfaState * @returns {prakalpa.parser.DFAState} dfaState - DFA State that the label in the transition table points to */ updateArcDFAState: function (label, nfaState) { if(!(label in this.arcs)) { this.arcs[label] = new DFAState(); } this.arcs[label].addClosure(nfaState); }, /** * Checks if the other DFA State is equal to this one * @param {prakalpa.parser.DFAState} other - The DFA State to compare this one against * @returns {Boolean} `true` if equal, else `false` */ equals: function (other) { var i; if(this.nfaStates.length !== other.nfaStates.length) { return false; } for(i = 0; i &lt; this.nfaStates.length; i++) { if(this.nfaStates[i] !== other.nfaStates[i]) { return false; } } return true; }, constructFollowSet: function (dfaGrammar) { array.forEach(this.arcs, function (arc) { var firstSet; if(arc.label in NonTerminals) { firstSet = dfaGrammar[arc.label].calcFirstSet(dfaGrammar); array.forEach(firstSet, function (label) { this.followSet[label] = { arrow: arc.arrow, nonTerminal: arc.label, }; }.bind(this)); } else { this.followSet[arc.label] = { arrow: arc.arrow, nonTerminal: null }; } }.bind(this)); } }); return DFAState; }); × Search results Close "},"parser_meta_grammar.js.html":{"id":"parser_meta_grammar.js.html","title":"Source: parser/meta_grammar.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/meta_grammar.js /* This meta-grammar is hand-written and will be used to * generate the DFAs of the actual Python grammar */ define([ 'prakalpa/constants/non_terminals', 'prakalpa/constants/tokens', 'prakalpa/parser/dfa_state', 'prakalpa/parser/dfa' ], function (NonTerminals, Tokens, DFAState, DFA) { /** * DFAs of a Meta Grammar that defines a language that accepts the Python's grammar * The meta grammar is hand-written and will be used to generate the DFAs of the actual Python grammar * It consists of 6 DFAs - `MSTART`, `RULE`, `RHS`, `ALT`, `ITEM`, `ATOM` * See the [references section](https://github.com/ashimaathri/prakalpa/tree/master/references/Python_metagrammar.pdf) on github for the state diagrams * @module prakalpa.parser.MetaGrammar */ return ({ 'MSTART': DFA({ type: 'MSTART', states: [ DFAState({ arcs: [ { label: NonTerminals.RULE, arrow: 0 }, { label: Tokens.NEWLINE, arrow: 0 }, { label: Tokens.ENDMARKER, arrow: 1 } ] }), DFAState({ arcs: [], isAccepting: true }) ], firstSet: [Tokens.NEWLINE, Tokens.NAME] }), 'RULE': DFA({ type: 'RULE', states: [ DFAState({ arcs: [ { label: Tokens.NAME, arrow: 1 } ] }), DFAState({ arcs: [ { label: Tokens.COLON, arrow: 2 } ] }), DFAState({ arcs: [ { label: NonTerminals.RHS, arrow: 3 } ] }), DFAState({ arcs: [ { label: Tokens.NEWLINE, arrow: 4 } ] }), DFAState({ arcs: [], isAccepting: true }) ], firstSet: [Tokens.NAME] }), 'RHS': DFA({ type: 'RHS', states: [ DFAState({ arcs: [ { label: NonTerminals.ALT, arrow: 1} ] }), DFAState({ arcs: [ { label: Tokens.VBAR, arrow: 0}, ], isAccepting: true }) ], firstSet: [Tokens.NAME, Tokens.STRING, Tokens.LPAR, Tokens.LSQB] }), 'ALT': DFA({ type: 'ALT', states: [ DFAState({ arcs: [ { label: NonTerminals.ITEM, arrow: 1 } ] }), DFAState({ arcs: [ { label: NonTerminals.ITEM, arrow: 1 }, ], isAccepting: true }) ], firstSet: [Tokens.NAME, Tokens.STRING, Tokens.LPAR, Tokens.LSQB] }), 'ITEM': DFA({ type: 'ITEM', states: [ DFAState({ arcs: [ { label: Tokens.LSQB, arrow: 1 }, { label: NonTerminals.ATOM, arrow: 2 } ] }), DFAState({ arcs: [ { label: NonTerminals.RHS, arrow: 3} ] }), DFAState({ arcs: [ { label: Tokens.STAR, arrow: 4 }, { label: Tokens.PLUS, arrow: 4 } ], isAccepting: true }), DFAState({ arcs: [ { label: Tokens.RSQB, arrow: 4 } ] }), DFAState({ arcs: [], isAccepting: true }) ], firstSet: [Tokens.NAME, Tokens.STRING, Tokens.LPAR, Tokens.LSQB] }), 'ATOM': DFA({ type: 'ATOM', states: [ DFAState({ arcs: [ { label: Tokens.NAME, arrow: 1 }, { label: Tokens.STRING, arrow: 1 }, { label: Tokens.LPAR, arrow: 2 } ] }), DFAState({ arcs: [], isAccepting: true }), DFAState({ arcs: [ { label: NonTerminals.RHS, arrow: 3 } ] }), DFAState({ arcs: [ { label: Tokens.RPAR, arrow: 1 } ] }) ], firstSet: [Tokens.NAME, Tokens.STRING, Tokens.LPAR] }), }); }); × Search results Close "},"parser_nfa.js.html":{"id":"parser_nfa.js.html","title":"Source: parser/nfa.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/nfa.js define([ 'dojo/_base/declare', 'dojo/_base/lang', 'prakalpa/constants/tokens' ], function (declare, lang, Terminals) { /** * Represents an NFA (Non-Deterministic Finite Automaton) * @class prakalpa.parser.NFA * @param {Object} opts * @param {String} opts.name - Name of the NFA */ return declare([], /** @lends prakalpa.parser.NFA.prototype */{ constructor: function (opts) { lang.mixin(this, opts); this._states = []; /** * Start state of NFA * @name prakalpa.parser.NFA#start * @type {Array} */ this.start = null; /** * End state of NFA * @name prakalpa.parser.NFA#end * @type {Array} */ this.end = null; }, /** * Set start state of NFA * @param {Array} start - start state of NFA */ setStart: function (start) { this.start = start; }, /** * Set end state of NFA * @param {Array} end - end state of NFA */ setEnd: function (end) { this.end = end; }, /** * Add a new state to the NFA * @returns {Array} Newly added state */ addNewState: function () { this._states.push([]); return this._states[this._states.length - 1]; }, /** * Adds an arc to state1 with an empty label and an arrow pointing to state2 * @param {Array} state1 - State that you want to add an arc to * @param {Array} state2 - State that the arc points to */ addEmptyArc: function (state1, state2) { state1.push({ label: Terminals.EMPTY, arrow: state2 }); }, /** * Adds an arc to state1 with the given label and an arrow pointing to state2 * @param {Array} state1 - State that you want to add an arc to * @param {Array} state2 - State that the arc points to * @param {String} label - Label on the arc */ addArc: function (state1, state2, label) { state1.push({ label: label, arrow: state2 }); } }); }); × Search results Close "},"parser_pgen.js.html":{"id":"parser_pgen.js.html","title":"Source: parser/pgen.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/pgen.js define([ 'dojo/_base/declare', 'dojo/_base/lang', 'dojo/_base/array', 'prakalpa/constants/non_terminals', 'prakalpa/constants/tokens', 'prakalpa/tokenizer', 'prakalpa/parser/nfa', 'prakalpa/parser/dfa', 'prakalpa/exceptions', 'prakalpa/utils' ], function (declare, lang, array, NonTerminals, Terminals, Tokenizer, NFA, DFA, Exceptions, Utils) { /** * Generates the Python Parser DFAs using the CST generated by parsing the Python Grammar using the MetaGrammar * @class prakalpa.parser.ParserGenerator * @param {Object} opts * @param {prakalpa.parser.ParseTreeNode} opts.parseTreeRoot - Root of CST generated by parsing the Python Grammar using the MetaGrammar */ return declare([], /** @lends prakalpa.parser.ParserGenerator.prototype */{ constructor: function (opts) { lang.mixin(this, opts); /** * The map containing all the Parser DFAs * @name prakalpa.parser.ParserGenerator#dfas * @type {Object.&lt;String, prakalpa.parser.DFA&gt;} */ this.dfas = {}; /** * Contains all the tokens (type and string value) of the Python Language * @name prakalpa.parser.ParserGenerator#labels * @type {Array&lt;Object&gt;} */ this.labels = []; this._nfas = {}; this._metaCompile(); this._makeDFAs(); this._translateLabels(); this._calcFirstSet(); }, /** * Adds a new label to the list if not already present * @private * @param {Object.&lt;String, String&gt;} newLabel - type and string of the new label to be added */ _addLabel: function (newLabel) { var existingLabel; existingLabel = array.filter(this.labels, function (label) { return (label.type === newLabel.type &amp;&amp; label.string === newLabel.string); }); if(!existingLabel.length) { this.labels.push(newLabel); } }, /** * Asserts if the current node under processing is the expected one * @private * @param {prakalpa.parser.ParseTreeNode} node - Node under processing * @param {String} symbol - Name of symbol * @throws {prakalpa.Exceptions.AssertionError} If the expectation is not met */ _REQ: function (node, expectedSymbol) { if(!node.is(expectedSymbol)) { throw new Exceptions.AssertionError('Expected ' + expectedSymbol + ', got ' + node.symbol); } }, /** * Asserts if the current node has the expected number of children * @private * @param {Array&lt;prakalpa.parser.ParseTreeNode&gt;} children - Children of a node * @param {Number} expectedNumChildren - Expected number of children * @throws {prakalpa.Exceptions.AssertionError} If the expectation is not met */ _REQN: function (children, expectedNumChildren) { if(children.length &lt; expectedNumChildren) { throw new Exceptions.AssertionError('Expected at least' + expectedNumChildren + ' children, got ' + children.length); } }, /** * Create DFAs from the NFAs compiled from the CST * @private */ _makeDFAs: function () { var nfa, type; for(type in this._nfas) { nfa = this._nfas[type]; this.dfas[type] = new DFA({type: type, nfa: nfa}); } }, /** * @private * @throws {prakalpa.Exceptions.InvalidNameLabel} If the NAME label is neither a terminal nor a non-terminal * @throws {prakalpa.Exceptions.InvalidOneCharLabel} If the one char label is not a valid one char token * @throws {prakalpa.Exceptions.InvalidTwoCharLabel} If the two char label is not a valid two char token * @throws {prakalpa.Exceptions.InvalidThreeCharLabel} If the three char label is not a valid three char token */ _translateLabels: function () { array.forEach(this.labels, function (label) { var keywordRegex, type; switch(label.type) { case Terminals.NAME: if(Utils.isNonTerminal(label.string, this.dfas) || Utils.isTerminal(label.string)) { label.type = label.string; } else { throw new Exceptions.InvalidNameLabel(label); } break; case Terminals.STRING: label.string = label.string.slice(1, -1); keywordRegex = /^[A-Za-z_]/; if(label.string.match(keywordRegex)) { label.type = Terminals.NAME; } else if(label.string.length === 1) { type = Utils.oneCharToken(label.string); if(type !== Terminals.OP) { label.type = type; } else { throw new Exceptions.InvalidOneCharLabel(label); } } else if(label.string.length === 2) { type = Utils.twoCharToken(label.string[0], label.string[1]); if(type !== Terminals.OP) { label.type = type; } else { throw new Exceptions.InvalidTwoCharLabel(label); } } else if(label.string.length === 3) { type = Utils.threeCharToken(label.string[0], label.string[1], label.string[2]); if(type !== Terminals.OP) { label.type = type; } else { throw new Exceptions.InvalidThreeCharLabel(label); } } break; default: // Don't do anything, the label is fine } }.bind(this)); }, /** * Calculates the first set of every dfa in the list * @private */ _calcFirstSet: function () { var type, dfa; for(type in this.dfas) { dfa = this.dfas[type]; dfa.calcFirstSet(this.dfas); } }, /** * Starts the compilation of the CST into NFAs * Similar to the algorithm given in [3.7.4 Construction of an NFA from a Regular Expression](http://www.informatik.uni-bremen.de/agbkb/lehre/ccfl/Material/ALSUdragonbook.pdf) * @private */ _metaCompile: function () { var i, child; this._REQ(this.parseTreeRoot, NonTerminals.MSTART); // Process all children (RULES) other than the last child (ENDMARKER) for(i = 0; i &lt; this.parseTreeRoot.children.length - 1; i++) { child = this.parseTreeRoot.children[i]; if(!child.is(Terminals.NEWLINE)) { this._compileRule(child); } } }, /** * Processes a grammar production rule * @private * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the production rule */ _compileRule: function (parseTreeNode) { var child, i, nfa, states, string; i = 0; this._REQ(parseTreeNode, NonTerminals.RULE); this._REQN(parseTreeNode.children, 4); child = parseTreeNode.children[i++]; this._REQ(child, Terminals.NAME); string = child.string; this._addLabel({ type: Terminals.NAME, string: string }); nfa = new NFA({ name: string }); this._nfas[string] = nfa; child = parseTreeNode.children[i++]; this._REQ(child, Terminals.COLON); child = parseTreeNode.children[i++]; this._REQ(child, NonTerminals.RHS); states = this._compileRHS(nfa, child); nfa.setStart(states.start); nfa.setEnd(states.end); child = parseTreeNode.children[i]; this._REQ(child, Terminals.NEWLINE); }, /** * Processes the right hand side of a grammar production rule * @private * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the rhs */ _compileRHS: function (nfa, parseTreeNode) { var child, i, newStart, newEnd, states, start, end; i = 0; this._REQ(parseTreeNode, NonTerminals.RHS); this._REQN(parseTreeNode.children, 1); child = parseTreeNode.children[i++]; this._REQ(child, NonTerminals.ALT); states = this._compileAlt(nfa, child); start = states.start; end = states.end; if(i &gt;= parseTreeNode.children.length) { return { start: start, end: end }; } newStart = nfa.addNewState(); newEnd = nfa.addNewState(); nfa.addEmptyArc(newStart, start); nfa.addEmptyArc(end, newEnd); start = newStart; end = newEnd; for(; i &lt; parseTreeNode.children.length; i++) { child = parseTreeNode.children[i]; this._REQ(child, Terminals.VBAR); this._REQN(parseTreeNode.children - i, 1); i++; child = parseTreeNode.children[i]; this._REQ(child, NonTerminals.ALT); states = this._compileAlt(nfa, child); nfa.addEmptyArc(start, states.start); nfa.addEmptyArc(states.end, end); } return { start: start, end: end }; }, /** * Processes alternatives (options separated by a | character in the RHS of a production rule) * @private * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the alternatives */ _compileAlt: function (nfa, parseTreeNode) { var child, i, states, start, end; i = 0; this._REQ(parseTreeNode, NonTerminals.ALT); this._REQN(parseTreeNode.children, 1); child = parseTreeNode.children[i++]; this._REQ(child, NonTerminals.ITEM); states = this._compileItem(nfa, child); start = states.start; end = states.end; for(; i &lt; parseTreeNode.children.length; i++) { child = parseTreeNode.children[i]; this._REQ(child, NonTerminals.ITEM); states = this._compileItem(nfa, child); nfa.addEmptyArc(end, states.start); end = states.end; } return { start: start, end: end }; }, /** * Processes each item on the RHS. An item maybe another non terminal or an expression with or without repeat directives * @private * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the alternatives */ _compileItem: function (nfa, parseTreeNode) { var child, i, states, start, end; i = 0; this._REQ(parseTreeNode, NonTerminals.ITEM); this._REQN(parseTreeNode.children, 1); child = parseTreeNode.children[i++]; if(child.is(Terminals.LSQB)) { this._REQN(parseTreeNode.children, 3); child = parseTreeNode.children[i++]; this._REQ(child, NonTerminals.RHS); start = nfa.addNewState(); end = nfa.addNewState(); nfa.addEmptyArc(start, end); states = this._compileRHS(nfa, child); nfa.addEmptyArc(start, states.start); nfa.addEmptyArc(states.end, end); child = parseTreeNode.children[i]; this._REQ(child, Terminals.RSQB); } else { states = this._compileAtom(nfa, child); start = states.start; end = states.end; if(i &gt;= parseTreeNode.children.length) { return { start: start, end: end }; } child = parseTreeNode.children[i]; nfa.addEmptyArc(end, start); if(child.is(Terminals.STAR)) { end = start; } else { this._REQ(child, Terminals.PLUS); } } return { start: start, end: end }; }, /** * Processes expressions in parenthesis and terminals * @private * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the alternatives */ _compileAtom: function (nfa, parseTreeNode) { var child, i, states, start, end; i = 0; this._REQ(parseTreeNode, NonTerminals.ATOM); this._REQN(parseTreeNode.children, 1); child = parseTreeNode.children[i++]; if(child.is(Terminals.LPAR)) { this._REQN(parseTreeNode.children, 3); child = parseTreeNode.children[i++]; this._REQ(child, NonTerminals.RHS); states = this._compileRHS(nfa, child); start = states.start; end = states.end; child = parseTreeNode.children[i]; this._REQ(child, Terminals.RPAR); } else if (child.is(Terminals.NAME) || child.is(Terminals.STRING)) { start = nfa.addNewState(); end = nfa.addNewState(); this._addLabel({ type: child.symbol, string: child.string }); nfa.addArc(start, end, child.string); } else { this._REQ(child, Terminals.NAME); } return { start: start, end: end }; } }); }); × Search results Close "},"parser_parse_tree_node.js.html":{"id":"parser_parse_tree_node.js.html","title":"Source: parser/parse_tree_node.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/parse_tree_node.js define([ 'dojo/_base/declare', 'dojo/_base/lang' ], function (declare, lang) { /** * @class prakalpa.parser.ParseTreeNode * @param {String} symbol - Type of NonTerminal or Terminal * @param {String} string - Value of terminal * @param {Number} lineNum - Line number of terminal * @param {Number} columnOffset - Column offset of terminal */ return declare([], /** @lends prakalpa.parser.ParseTreeNode.prototype */{ constructor: function (opts) { lang.mixin(this, opts); /** * Children of this node * @name prakalpa.parser.ParseTreeNode#children * @type {Array&lt;prakalpa.parser.ParseTreeNode&gt;} */ this.children = []; /** * Value of terminal * @name prakalpa.parser.ParseTreeNode#string * @type {String} */ /** * Type of NonTerminal or Terminal * @name prakalpa.parser.ParseTreeNode#symbol * @type {String} */ }, /** * Adds a child to this node * @param {prakalpa.parser.ParseTreeNode} child - The child you want to add */ addChild: function (child) { this.children.push(child); }, /** * Checks if the symbol for this node is the same as the given symbol * @param {String} symbol */ is: function (symbol) { return (this.symbol === symbol); }, }); }); × Search results Close "},"parser_stack.js.html":{"id":"parser_stack.js.html","title":"Source: parser/stack.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: parser/stack.js define([ 'dojo/_base/declare' ], function (declare) { /** * @class prakalpa.parser.Stack * @extends Array */ return declare([Array], /** @lends prakalpa.parser.Stack.prototype */{ /** * Get the value of the propertyName at the top of the stack if present, else return the top of the stack * @param [String] propertyName * @returns {Object} Value of property or object at the top of the stack */ peek: function (propertyName) { var topEntry; topEntry = this[this.length - 1]; if(propertyName) { return topEntry[propertyName]; } else { return topEntry; } }, /** * Checks if stack is empty * @returns {Boolean} */ isEmpty: function () { return !this.length; }, /** * Updates the the value of the property at the top of the stack * @param {String} propertyName - Name of property you want to update * @param {Object} newValue - New value of the property */ updateTop: function (propertyName, newValue) { var topEntry; topEntry = this.peek(); topEntry[propertyName] = newValue; } }); }); × Search results Close "},"token.js.html":{"id":"token.js.html","title":"Source: token.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: token.js define([ 'dojo/_base/declare', 'dojo/_base/lang', ], function (declare, lang) { /** * Represents a token * @class prakalpa.Token * @property {prakalpa.constants.tokens} type - Type of token * @property {Object} start - The position at which the token starts * @property {number} start.column - The column number in a line at which the token starts * @property {number} start.lineNum - The line number in the source at which the token starts * @property {Object} end - The position just before which the token ends * @property {number} end.column - The column number in a line before which the token ends * @property {number} end.lineNum - The line number in the source before which the token ends * @property {string} string - String value of token */ return declare([], { constructor: function (opts) { lang.mixin(this, opts); } }); }); × Search results Close "},"tokenizer.js.html":{"id":"tokenizer.js.html","title":"Source: tokenizer.js","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Source: tokenizer.js /* * This is a port of cpython's tokenizer, Parser/tokenizer.c, * in particular, the tok_get function. */ define([ 'dojo/_base/declare', 'dojo/_base/lang', 'prakalpa/constants/tokens', 'prakalpa/constants/errors', 'prakalpa/exceptions', 'prakalpa/token', 'prakalpa/utils' ], function (declare, lang, Tokens, Errors, Exceptions, Token, Utils) { var MAXINDENT; MAXINDENT = 100; /** * The tokenizer splits a string into Python tokens * @class prakalpa.Tokenizer * @param opts * @param {String} opts.sourceText - Source that needs to be tokenized */ return declare([], /** @lends prakalpa.Tokenizer.prototype */{ constructor: function (opts) { lang.mixin(this, opts); this._atBeginningOfLine = true; this._level = 0; // Parenthesis/Square Bracket/Braces nesting level this._indstack = [0]; this._indent = 0; this._pending = 0; this._charIndex = -1; this._startOfToken = {}; this._contLine = false; this._lineNum = 1; this._colNum = -1; this._lines = this.sourceText.split('\\n'); this._blankline = false; }, /** * Entrypoint into the tokenizer. Returns the next token in the stream * @public * @returns {prakalpa.Token} token - Next token * @throws {prakalpa.Exceptions.TokenizeError} Will throw an error if a syntax errors is encountered */ getNext: function () { return this._nextline(); }, /** * Returns the value of the token starting at position `start` and ending * just before position `end` both columnwise and linewise * @private * @param {Object} start - The position at which the token starts * @param {Number} start.column - The column number in a line at which the token starts * @param {Number} start.lineNum - The line number in the source at which the token starts * @param {Object} end - The position just before which the token ends * @param {Number} end.column - The column number in a line before which the token ends * @param {Number} end.lineNum - The line number in the source before which the token ends * @returns {String} tokenString - String value of token starting at start and ending just before end */ _getString: function (start, end) { var startLine, endLine, startColumn, endColumn, string, i; startColumn = start.column; endColumn = end.column; startLine = start.lineNum - 1; endLine = end.lineNum - 1; if(startLine === endLine) { string = this._lines[startLine].substring(startColumn, endColumn); } else { string = this._lines[startLine].substring(startColumn); for(i = startLine + 1; i &lt; endLine - 1; i++) { string += this._lines[i] + '\\n'; } string += this._lines[i].substring(0, endColumn); } return string; }, /** * Get the next character in the stream and keep track of line number and * column number * @private * @returns {String} nextChar - Next character in the source text */ _getNextChar: function () { if(this.sourceText[this._charIndex] === '\\n') { this._lineNum++; this._colNum = -1; } this._charIndex++; this._colNum++; if(this._charIndex &gt;= this.sourceText.length) { return; } return this.sourceText[this._charIndex]; }, /** * Go back one character in the stream while accounting for newlines * @private */ _backupOneChar: function () { if(this._charIndex === -1) { return; } this._charIndex--; this._colNum--; if(this.sourceText[this._charIndex] === '\\n') { this._lineNum--; } }, /** * Processes one line and keeps track of indents and dedents. * Corresponds to the `nextline` goto label in cpython's `tok_get` function. * @private */ _nextline: function () { this._startOfToken = { column: 0, lineNum: this._lineNum }; this._blankline = false; if(this._atBeginningOfLine) { this._atBeginningOfLine = false; this._countIndentsAndDedents(); } this._startOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; if(this._pending !== 0) { if(this._pending &lt; 0) { this._pending++; return Token({ type: Tokens.DEDENT, start: this._startOfToken }); } else { this._pending--; return Token({ type: Tokens.INDENT, start: this._startOfToken }); } } // TODO Add support for async return this._again(); }, /** * Checks if an identifier is a proper unicode string PEP 3131 (TODO) * @private */ _verifyIdentifier: function () { return false; }, /** * Checks for an identifier which is the most frequent token * @private * @param {String} c - The next character in the source */ _processNames: function (c) { var nonascii, saw_b, saw_r, saw_u, endOfToken; nonascii = false; saw_b = saw_r = saw_u = false; while(true) { if(!(saw_b || saw_u) &amp;&amp; (c === 'b' || c === 'B')) { saw_b = true; } else if(!(saw_b || saw_u || saw_r) &amp;&amp; (c === 'u' || c === 'U')) { saw_u = true; } else if(!(saw_r || saw_u) &amp;&amp; (c === 'r' || c === 'R')) { saw_r = true; } else { break; } c = this._getNextChar(); if(c === '&quot;' || c === &quot;'&quot;) { return this._letterQuote(c); } } while (this._isPotentialIdentifierChar(c)) { if(c.charCodeAt(0) &gt;= 128) { nonascii = true; } c = this._getNextChar(); } this._backupOneChar(); if(nonascii &amp;&amp; !this._verifyIdentifier()) { throw new Exceptions.TokenizeError({ message: Errors.TOKEN, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } //TODO Add support for async endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.NAME, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); }, /** Equivalent to the `again` label in cpython's `tok_get` * Processes newlines and the endmarker. * @private */ _again: function () { var c, endOfToken; //TODO Add support for tabs and form feeds do { c = this._getNextChar(); } while (c === ' '); this._startOfToken = { column: this._colNum, lineNum: this._lineNum }; if(c === '#') { while (c &amp;&amp; c !== '\\n') { c = this._getNextChar(); } } if(!c) { return Token({ type: Tokens.ENDMARKER, start: this._startOfToken }); } if(this._isPotentialIdentifierStart(c)) { return this._processNames(c); } if(c === '\\n') { this._atBeginningOfLine = true; if(this._blankline || this._level &gt; 0) { return this._nextline(); } this._contLine = false; endOfToken = { column: this._colNum, lineNum: this._lineNum }; return Token({ type: Tokens.NEWLINE, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } return this._startWithPeriod(c); }, /** * If the token begins with a period, processes that token, else * calls the next processor in line * @private */ _startWithPeriod: function (c) { var endOfToken; if(c === '.') { c = this._getNextChar(); if(this._isDigit(c)) { return this._fraction(); } else if(c === '.') { c = this._getNextChar(); if(c === '.') { endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.ELLIPSIS, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } else { this._backupOneChar(); } this._backupOneChar(); } else { this._backupOneChar(); } endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.DOT, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } return this._isNumber(c); }, /** * If the token is a number, processes that token, else * calls the next processor in line * @private */ _isNumber: function (c) { var nonZero, charCode, endOfToken; if(this._isDigit(c)) { if(c === '0') { c = this._getNextChar(); if(c === '.') { return this._fraction(); } if(c === 'j' || c === 'J') { return this._imaginary(); } if(c === 'x' || c === 'X') { c = this._getNextChar(); if(!this._isXDigit(c)) { this._backupOneChar(); throw new Exceptions.TokenizeError({ message: Errors.TOKEN, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } do { c = this._getNextChar(); } while(this._isXDigit(c)); } else if(c === 'o' || c === 'O') { c = this._getNextChar(); charCode = c.charCodeAt(0); if(charCode &lt; 48 || charCode &gt;= 56) { // Only '0' to '7' are allowed this._backupOneChar(); throw new Exceptions.TokenizeError({ message: Errors.TOKEN, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } do { c = this._getNextChar(); } while (c &amp;&amp; 48 &lt;= c.charCodeAt(0) &amp;&amp; c.charCodeAt(0) &lt; 56); } else if(c === 'b' || c === 'B') { c = this._getNextChar(); if(c !== '0' &amp;&amp; c !== '1') { this._backupOneChar(); throw new Exceptions.TokenizeError({ message: Errors.TOKEN, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } do { c = this._getNextChar(); } while (c === '0' || c === '1'); } else { nonZero = false; while(c === '0') { c = this._getNextChar(); } while(this._isDigit(c)) { nonZero = true; c = this._getNextChar(); } if(c === '.') { return this._fraction(); } else if(c === 'e' || c === 'E') { return this._exponent(); } else if(c === 'j' || c === 'J') { return this._imaginary(); } else if (nonZero) { this._backupOneChar(); throw new Exceptions.TokenizeError({ message: Errors.TOKEN, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } } } else { do { c = this._getNextChar(); } while (this._isDigit(c)); if(c === '.') { return this._fraction(); } if(c === 'e' || c === 'E') { return this._exponent(); } if(c === 'j' || c === 'J') { return this._imaginary(); } } this._backupOneChar(); endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.NUMBER, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } return this._letterQuote(c); }, /** * Processes a fraction token. Equivalent to the `fraction` label in cpython's `tok_get` * @private */ _fraction: function (c) { var endOfToken; do { c = this._getNextChar(); } while (this._isDigit(c)); if(c === 'e' || c === 'E') { return this._exponent(); } if(c === 'j' || c === 'J') { return this._imaginary(); } this._backupOneChar(); endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.NUMBER, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); }, /** * Processes an exponent token. Equivalent to the `exponent` label in cpython's `tok_get` * @private */ _exponent: function () { var c, endOfToken; c = this._getNextChar(); if(c === '+' || c === '-') { c = this._getNextChar(); if(!this._isDigit(c)) { this._backupOneChar(); throw new Exceptions.TokenizeError({ message: Errors.TOKEN, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } } else if(!this._isDigit(c)) { this._backupOneChar(); this._backupOneChar(); endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.NUMBER, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } do { c = this._getNextChar(); } while(this._isDigit(c)); if(c === 'j' || c === 'J') { return this._imaginary(); } this._backupOneChar(); endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.NUMBER, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); }, /** * Processes an imaginary token. Equivalent to the `imaginary` label in cpython's `tok_get` * @private */ _imaginary: function () { var endOfToken; endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.NUMBER, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); }, /** * If token is a string token, processes that token, else * continues to the next processor in line. * Equivalent to the `letter_quote` label in cpython's `tok_get` * @private */ _letterQuote: function (c) { var quote, quoteSize, endQuoteSize, endOfToken; if(c === '&quot;' || c === &quot;'&quot;) { quote = c; quoteSize = 1; endQuoteSize = 0; c = this._getNextChar(); if(c === quote) { c = this._getNextChar(); if(c === quote) { quoteSize = 3; } else { endQuoteSize = 1; } } if(c !== quote) { this._backupOneChar(); } while(endQuoteSize !== quoteSize) { c = this._getNextChar(); if(!c) { if(quoteSize === 3) { throw new Exceptions.TokenizeError({ message: Errors.EOFS, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } else { throw new Exceptions.TokenizeError({ message: Errors.EOLS, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } } if(quoteSize === 1 &amp;&amp; c === '\\n') { throw new Exceptions.TokenizeError({ message: Errors.EOLS, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } if(c === quote) { endQuoteSize += 1; } else { endQuoteSize = 0; if(c === '\\\\') { c = this._getNextChar(); } } } endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Tokens.STRING, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } return this._lineContinuation(c); }, /** * If there's a line continuation in the source, processes that * and continues to the next processor in line. * @private */ _lineContinuation: function (c) { if(c === '\\\\') { c = this._getNextChar(); if(c !== '\\n') { throw new Exceptions.TokenizeError({ message: Errors.LINECONT, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } this._contLine = true; return this._again(); } return this._twoCharacter(c); }, /** * Processes a two character token else continues to the next processor in line * @private */ _twoCharacter: function (c) { var c2, c3, token, token3, endOfToken; c2 = this._getNextChar(); token = Utils.twoCharToken(c, c2); if(token !== Tokens.OP) { c3 = this._getNextChar(); token3 = Utils.threeCharToken(c, c2, c3); if(token3 !== Tokens.OP) { token = token3; } else { this._backupOneChar(); } endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: token, start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); } this._backupOneChar(); return this._parenthesesCheck(c); }, /** * Matches braces, parenthesis and square brackets * @private */ _parenthesesCheck: function (c) { switch(c) { case '(': case '[': case '{': this._level++; break; case ')': case ']': case '}': this._level--; break; } return this._oneCharacter(c); }, /** * Processes a one character token else continues to the next processor in line * @private */ _oneCharacter: function (c) { var endOfToken; endOfToken = { column: this._colNum + 1, lineNum: this._lineNum }; return Token({ type: Utils.oneCharToken(c), start: this._startOfToken, end: endOfToken, string: this._getString(this._startOfToken, endOfToken) }); }, /** * Checks if the token begins with a valid identifier start character * @private */ _isPotentialIdentifierStart: function (c) { var code; if(typeof(c) === 'undefined') { return false; } code = c.charCodeAt(0); return ((code &gt; 64 &amp;&amp; code &lt; 91) || // Uppercase (code &gt; 96 &amp;&amp; code &lt; 123) || // Lowercase (code &gt;= 128) || // More than ASCII (c === '_')); }, /** * Checks if the char is a valid identifier character * @private */ _isPotentialIdentifierChar: function (c) { var code; if(typeof(c) === 'undefined') { return false; } code = c.charCodeAt(0); return ((code &gt; 64 &amp;&amp; code &lt; 91) || // Uppercase (code &gt; 96 &amp;&amp; code &lt; 123) || // Lowercase (code &gt; 47 &amp;&amp; code &lt; 58) || // Digit (code &gt;= 128) || // More than ASCII (c === '_')); }, /** * Matches indents and dedents * Algorithm description taken from [Tokens and Python's Lexical Structure](https://www.ics.uci.edu/~pattis/ICS-31/lectures/tokens.pdf) * 1. Ensure that the first line has no indentation (0 white-space characters); if it does, report an error. * If it doesn't, initialize the list with the value 0. * 2. For each logical line (after line–joining) * 1. If the current line’s indentation is &gt; the indentation at the list’s end * 1. Add the current line’s indentation to the end of the list. * 2. Produce an INDENT token. * 2. If the current line’s indentation is &lt; the indentation at the list’s end * 1. For each value at the end of the list that is unequal to the current line’s * indentation (if it is not in the list, report a lexical error). * 1. Remove the value from the end of the list. * 2. Produce a DEDENT token. * 3. Tokenize the current line. * 3. For every indentation on the list except 0, produce a DEDENT token. * @private */ _countIndentsAndDedents: function () { var col, c; col = 0; // Supporting only whitespace for now. // TODO Add support for tabs and form-feed c = this._getNextChar(); while(c === ' ') { col++; c = this._getNextChar(); } this._backupOneChar(); // TODO Add support for interactive mode if(c === '\\#' || c === '\\n') { this._blankline = true; } // I think altcol, altindstack etc. are to check if tabs and spaces // are being used inconsistently in indentation. // As we don't support tabs anyway, I'm skipping that part of the code if(!this._blankline &amp;&amp; this._level === 0) { if(col &gt; this._indstack[this._indent]) { if(this._indent + 1 &gt;= MAXINDENT) { throw new Exceptions.TokenizeError({ message: Errors.TOODEEP, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } this._pending++; this._indstack[++this._indent] = col; } else if (col &lt; this._indstack[this._indent]) { while(this._indent &gt; 0 &amp;&amp; col &lt; this._indstack[this._indent]) { this._pending--; this._indent--; } if(col !== this._indstack[this._indent]) { throw new Exceptions.TokenizeError({ message: Errors.DEDENT, type: Tokens.ERRORTOKEN, lineNum: this._lineNum }); } } } }, /** * Checks if character is a decimal digit or not * @private */ _isDigit: function (c) { var charCode; if(typeof(c) === 'undefined') { return false; } charCode = c.charCodeAt(0); return (charCode &gt; 47 &amp;&amp; charCode &lt; 58); }, /** * Checks if character is a hexadecimal digit or not * @private */ _isXDigit: function (c) { var charCode; if(typeof(c) === 'undefined') { return false; } charCode = c.charCodeAt(0); return (this._isDigit(c) || (charCode &gt;= 65 &amp;&amp; charCode &lt;= 70) || // A to F (charCode &gt;= 97 &amp;&amp; charCode &lt;= 102)); // a to f } }); }); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Modules Classes Exceptions AssertionError InvalidNameLabel InvalidOneCharLabel InvalidThreeCharLabel InvalidTwoCharLabel LeftRecursion SyntaxError TokenizeError DFA DFAState NFA Parser ParserGenerator ParseTreeNode Stack Token Tokenizer Namespaces prakalpa parser × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Classes Classes Exceptions AssertionError InvalidNameLabel InvalidOneCharLabel InvalidThreeCharLabel InvalidTwoCharLabel LeftRecursion SyntaxError TokenizeError DFA DFAState NFA Parser ParserGenerator ParseTreeNode Stack Token Tokenizer Namespaces prakalpa parser × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Namespaces Classes Exceptions AssertionError InvalidNameLabel InvalidOneCharLabel InvalidThreeCharLabel InvalidTwoCharLabel LeftRecursion SyntaxError TokenizeError DFA DFAState NFA Parser ParserGenerator ParseTreeNode Stack Token Tokenizer Namespaces prakalpa parser × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer × Search results Close "},"prakalpa.html":{"id":"prakalpa.html","title":"Namespace: prakalpa","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Namespace: prakalpa prakalpa Source: main.js, line 1 Classes Exceptions Token Tokenizer Namespaces parser × Search results Close "},"prakalpa.Exceptions.html":{"id":"prakalpa.Exceptions.html","title":"Class: Exceptions","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: Exceptions prakalpa. Exceptions new Exceptions() Source: exceptions.js, line 2 Classes AssertionError InvalidNameLabel InvalidOneCharLabel InvalidThreeCharLabel InvalidTwoCharLabel LeftRecursion SyntaxError TokenizeError × Search results Close "},"prakalpa.Exceptions.AssertionError.html":{"id":"prakalpa.Exceptions.AssertionError.html","title":"Class: AssertionError","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: AssertionError prakalpa.Exceptions. AssertionError new AssertionError() Source: exceptions.js, line 18 × Search results Close "},"prakalpa.Exceptions.InvalidNameLabel.html":{"id":"prakalpa.Exceptions.InvalidNameLabel.html","title":"Class: InvalidNameLabel","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: InvalidNameLabel prakalpa.Exceptions. InvalidNameLabel new InvalidNameLabel() A NAME label should either be a Terminal or a NonTerminal Source: exceptions.js, line 23 × Search results Close "},"prakalpa.Exceptions.InvalidOneCharLabel.html":{"id":"prakalpa.Exceptions.InvalidOneCharLabel.html","title":"Class: InvalidOneCharLabel","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: InvalidOneCharLabel prakalpa.Exceptions. InvalidOneCharLabel new InvalidOneCharLabel() Source: exceptions.js, line 31 × Search results Close "},"prakalpa.Exceptions.InvalidThreeCharLabel.html":{"id":"prakalpa.Exceptions.InvalidThreeCharLabel.html","title":"Class: InvalidThreeCharLabel","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: InvalidThreeCharLabel prakalpa.Exceptions. InvalidThreeCharLabel new InvalidThreeCharLabel() Source: exceptions.js, line 45 × Search results Close "},"prakalpa.Exceptions.InvalidTwoCharLabel.html":{"id":"prakalpa.Exceptions.InvalidTwoCharLabel.html","title":"Class: InvalidTwoCharLabel","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: InvalidTwoCharLabel prakalpa.Exceptions. InvalidTwoCharLabel new InvalidTwoCharLabel() Source: exceptions.js, line 38 × Search results Close "},"prakalpa.Exceptions.LeftRecursion.html":{"id":"prakalpa.Exceptions.LeftRecursion.html","title":"Class: LeftRecursion","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: LeftRecursion prakalpa.Exceptions. LeftRecursion new LeftRecursion() Source: exceptions.js, line 3 × Search results Close "},"prakalpa.Exceptions.SyntaxError.html":{"id":"prakalpa.Exceptions.SyntaxError.html","title":"Class: SyntaxError","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: SyntaxError prakalpa.Exceptions. SyntaxError new SyntaxError() Source: exceptions.js, line 13 × Search results Close "},"prakalpa.Exceptions.TokenizeError.html":{"id":"prakalpa.Exceptions.TokenizeError.html","title":"Class: TokenizeError","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: TokenizeError prakalpa.Exceptions. TokenizeError new TokenizeError() Source: exceptions.js, line 8 × Search results Close "},"prakalpa.module_utils.html":{"id":"prakalpa.module_utils.html","title":"Module: utils","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Module: utils Source: utils.js, line 5 Methods &lt;inner&gt; isNonTerminal(token, dfas) Checks if token is a non-terminal. This method has been added for readability purposes. Parameters: Name Type Description token String type of token dfas Object.&lt;String, prakalpa.parser.DFA&gt; Map of DFA type to DFA Source: utils.js, line 15 Returns: Type Boolean &lt;inner&gt; isTerminal(token) Checks if token is a terminal Parameters: Name Type Description token String type of token Source: utils.js, line 24 Returns: Type Boolean &lt;inner&gt; oneCharToken(c) Returns token corresponding to one character string Parameters: Name Type Description c string One character string Source: utils.js, line 33 Returns: Token type Type prakalpa.constants.Tokens &lt;inner&gt; threeCharToken(c1, c2, c3) Returns token corresponding to three character string Parameters: Name Type Description c1 string First character c2 string Second character c3 string Third character Source: utils.js, line 152 Returns: Type prakalpa.constants.Tokens &lt;inner&gt; twoCharToken(c1, c2) Returns token corresponding to two character string Parameters: Name Type Description c1 string First character c2 string Second character Source: utils.js, line 68 Returns: Type prakalpa.constants.Tokens × Search results Close "},"prakalpa.parser.html":{"id":"prakalpa.parser.html","title":"Namespace: parser","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Namespace: parser prakalpa. parser Source: parser/main.js, line 5 Classes DFA DFAState NFA Parser ParserGenerator ParseTreeNode Stack × Search results Close "},"prakalpa.parser.DFA.html":{"id":"prakalpa.parser.DFA.html","title":"Class: DFA","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: DFA prakalpa.parser. DFA new DFA(opts) Represents a DFA (deterministic finite automaton) Parameters: Name Type Argument Description opts Object Properties Name Type Description type String NonTerminal constant that represents this DFA nfa prakalpa.parser.NFA The NFA from which the DFA must be constructed Array &lt;optional&gt; opts.states - The DFA states of this DFA. This only needs to be supplied at parser generation time. Every other time, it is constructed programmatically. Object. &lt;optional&gt; opts.firstSet - A dict (used for fast membership checks) with all the labels of the firstSet as keys. The value doesn't matter. Only needs to be supplied at parser generation time. Source: parser/dfa.js, line 11 Members states :Array.&lt;prakalpa.parser.DFAState&gt; States of the DFA. The first state at index 0 is always the start state. Type: Array.&lt;prakalpa.parser.DFAState&gt; Source: parser/dfa.js, line 24 Methods &lt;private&gt; _addState(dfaState) Adds a DFA state to the list only if not already present. Parameters: Name Type Description dfaState prakalpa.parser.DFAState DFA state to add to list Source: parser/dfa.js, line 84 Returns: newState? - True if new state, false if state is already in the list Type Boolean &lt;private&gt; _generateDFA(state) Generates DFAs recursively, starting at the start state that has already been constructed in the constructor, and visiting the nfa nodes reachable from all the states in the start stateBased on 3.7.1 Conversion of an NFA to a DFA from the Dragon Book 2nd Edition Parameters: Name Type Description state prakalpa.parser.DFAState DFA state to start discovery from Source: parser/dfa.js, line 56 calcFirstSet(dfaGrammar) Calculates the firstSet of this DFA. From the Dragon Book: We define FIRST (a) to be the set of terminals that appear as the first symbols of one or more strings of terminals generated from a Parameters: Name Type Description dfaGrammar Object.&lt;String, prakalpa.parser.DFA&gt; A map containing all the DFAs for this grammar Source: parser/dfa.js, line 107 Throws: If the grammar is left recursive. Type prakalpa.Exceptions.LeftRecursion Returns: firstSet - A dict (used for fast membership checks) with all the labels of the firstSet as keys. The value doesn't matter. Type Object.&lt;String, Boolean&gt; constructFollowSet(dfaGrammar) Constructs the transition table for each state in this DFA Parameters: Name Type Description dfaGrammar Object.&lt;String, prakalpa.parser.DFA&gt; A map containing all the DFAs for this grammar Source: parser/dfa.js, line 140 × Search results Close "},"prakalpa.parser.DFAState.html":{"id":"prakalpa.parser.DFAState.html","title":"Class: DFAState","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: DFAState prakalpa.parser. DFAState new DFAState( [Object]) Represents a DFA State Parameters: Name Type Argument Description Object &lt;optional&gt; opts opts.arcs Array Arcs of this DFA State. This is constructed programmatically in all cases except during parser generation where we use the hard-coded metagrammar arcs. opts.isAccepting Boolean Denotes if this state is a final/accepting state. This is usually set using the method setEndState but should be provided to the constructor during parser generation. Source: parser/dfa_state.js, line 9 Members arcs :Object.&lt;String, prakalpa.parser.DFAState&gt; Map that has labels(can be Terminals or NonTerminals) as keys and DFA States as values. Type: Object.&lt;String, prakalpa.parser.DFAState&gt; Source: parser/dfa_state.js, line 24 followSet :Object.&lt;String, prakalpa.parser.DFAState&gt; Map that has Terminal labels as keys and DFA States as values. Type: Object.&lt;String, prakalpa.parser.DFAState&gt; Source: parser/dfa_state.js, line 30 isAccepting :Boolean Indicates if this DFA state is an accepting state or not Type: Boolean Source: parser/dfa_state.js, line 36 nfaStates :Array.&lt;Object&gt; Array of NFA States Type: Array.&lt;Object&gt; Source: parser/dfa_state.js, line 18 Methods &lt;private&gt; _nfaStateAbsent(nfaState) Checks if nfaState is absent from list Parameters: Name Type Description nfaState Object Source: parser/dfa_state.js, line 50 Returns: Type Boolean addClosure(nfaState) Add the epsilon closure of the given NFA State to this DFA State Parameters: Name Type Description nfaState Array An array of arcs Source: parser/dfa_state.js, line 92 addNFAState(nfaState) Adds nfaState to the list Parameters: Name Type Description nfaState Object Source: parser/dfa_state.js, line 67 containsNFAState(nfaState) Checks if nfaState is present in the list Parameters: Name Type Description nfaState Object Source: parser/dfa_state.js, line 59 Returns: Type Boolean equals(other) Checks if the other DFA State is equal to this one Parameters: Name Type Description other prakalpa.parser.DFAState The DFA State to compare this one against Source: parser/dfa_state.js, line 121 Returns: true if equal, else false Type Boolean fixReferences(dfaStates) Points numbered arrows in the metagrammar into corresponding DFAStates instead Parameters: Name Type Description dfaStates Array.&lt;prakalpa.parser.DFAState&gt; All states of the DFA this state belongs to Source: parser/dfa_state.js, line 75 setAsEndState() Mark this DFA state as an end/final/accepting state Source: parser/dfa_state.js, line 84 updateArcDFAState(label, nfaState) Update the DFA State pointed to by the label in the transition table with the epsilon closure of the given NFA State Parameters: Name Type Description label String The label on the arc nfaState Array Array of arcs in the nfaState Source: parser/dfa_state.js, line 109 Returns: dfaState - DFA State that the label in the transition table points to Type prakalpa.parser.DFAState × Search results Close "},"prakalpa.parser.module_MetaGrammar.html":{"id":"prakalpa.parser.module_MetaGrammar.html","title":"Module: MetaGrammar","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Module: MetaGrammar DFAs of a Meta Grammar that defines a language that accepts the Python's grammarThe meta grammar is hand-written and will be used to generate the DFAs of the actual Python grammarIt consists of 6 DFAs - MSTART, RULE, RHS, ALT, ITEM, ATOMSee the references section on github for the state diagrams Source: parser/meta_grammar.js, line 10 × Search results Close "},"prakalpa.parser.NFA.html":{"id":"prakalpa.parser.NFA.html","title":"Class: NFA","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: NFA prakalpa.parser. NFA new NFA(opts) Represents an NFA (Non-Deterministic Finite Automaton) Parameters: Name Type Description opts Object Properties Name Type Description name String Name of the NFA Source: parser/nfa.js, line 6 Members end :Array End state of NFA Type: Array Source: parser/nfa.js, line 22 start :Array Start state of NFA Type: Array Source: parser/nfa.js, line 16 Methods addArc(state1, state2, label) Adds an arc to state1 with the given label and an arrow pointing to state2 Parameters: Name Type Description state1 Array State that you want to add an arc to state2 Array State that the arc points to label String Label on the arc Source: parser/nfa.js, line 73 addEmptyArc(state1, state2) Adds an arc to state1 with an empty label and an arrow pointing to state2 Parameters: Name Type Description state1 Array State that you want to add an arc to state2 Array State that the arc points to Source: parser/nfa.js, line 60 addNewState() Add a new state to the NFA Source: parser/nfa.js, line 50 Returns: Newly added state Type Array setEnd(end) Set end state of NFA Parameters: Name Type Description end Array end state of NFA Source: parser/nfa.js, line 42 setStart(start) Set start state of NFA Parameters: Name Type Description start Array start state of NFA Source: parser/nfa.js, line 34 × Search results Close "},"prakalpa.parser.Parser.html":{"id":"prakalpa.parser.Parser.html","title":"Class: Parser","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: Parser prakalpa.parser. Parser new Parser(opts) Parameters: Name Type Description opts Object Properties Name Type Description grammar Object.&lt;String, prakalpa.parser.Parser.DFA&gt; The grammar containing all the DFAs start String The start symbol of the grammar sourceText String The text that needs to be parsed using this grammar Source: parser/main.js, line 19 Methods &lt;private&gt; _addToken(parserState, currentParseTreeNode) Adds a token to the concrete syntax tree using a table driven (followSet + stack) top-down predictive parsing algorithm. The grammar must be LL(1) for this to work and Python's grammar is by choice an LL(1) grammar. Parameters: Name Type Description parserState Object Current state of parser currentParseTreeNode prakalpa.parser.ParseTreeNode The concrete syntax tree node which we are processing currently Source: parser/main.js, line 128 Throws: If the source does not belong to the language generated by the given grammar Type prakalpa.Exceptions.ParseError &lt;private&gt; _push(parserState, currentParseTreeNode) Adds node to CST, moves current dfa to next state, pushes current parser state on to the stack and goes to the first state of the new dfaTop of the stack will point to the new dfa at state 0 at the end of this method. Parameters: Name Type Description parserState Object Current state of parser currentParseTreeNode prakalpa.parser.ParseTreeNode The concrete syntax tree node which we are processing currently Source: parser/main.js, line 109 &lt;private&gt; _shift(parserState, currentParseTreeNode) Adds node to CST and moves current dfa to the next stateTop of the stack will point to the current dfa at the parserState.nextState at the end of this method Parameters: Name Type Description parserState Object Current state of parser currentParseTreeNode prakalpa.parser.ParseTreeNode The concrete syntax tree node which we are processing currently Source: parser/main.js, line 82 Returns: childNode - New node added to currentParseTreeNode as a child Type prakalpa.parser.ParseTreeNode parse() Entrypoint into the parser. Source: parser/main.js, line 63 Returns: parseTreeRoot - The root of the concrete syntax tree Type prakalpa.parser.ParseTreeNode × Search results Close "},"prakalpa.parser.ParserGenerator.html":{"id":"prakalpa.parser.ParserGenerator.html","title":"Class: ParserGenerator","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: ParserGenerator prakalpa.parser. ParserGenerator new ParserGenerator(opts) Generates the Python Parser DFAs using the CST generated by parsing the Python Grammar using the MetaGrammar Parameters: Name Type Description opts Object Properties Name Type Description parseTreeRoot prakalpa.parser.ParseTreeNode Root of CST generated by parsing the Python Grammar using the MetaGrammar Source: parser/pgen.js, line 13 Members dfas :Object.&lt;String, prakalpa.parser.DFA&gt; The map containing all the Parser DFAs Type: Object.&lt;String, prakalpa.parser.DFA&gt; Source: parser/pgen.js, line 22 labels :Array.&lt;Object&gt; Contains all the tokens (type and string value) of the Python Language Type: Array.&lt;Object&gt; Source: parser/pgen.js, line 28 Methods &lt;private&gt; _addLabel(newLabel) Adds a new label to the list if not already present Parameters: Name Type Description newLabel Object.&lt;String, String&gt; type and string of the new label to be added Source: parser/pgen.js, line 47 &lt;private&gt; _calcFirstSet() Calculates the first set of every dfa in the list Source: parser/pgen.js, line 154 &lt;private&gt; _compileAlt(nfa, parseTreeNode) Processes alternatives (options separated by a | character in the RHS of a production rule) Parameters: Name Type Description nfa prakalpa.parser.NFA The NFA representing the production rule parseTreeNode prakalpa.parser.ParseTreeNode The node that represents the start of the alternatives Source: parser/pgen.js, line 268 &lt;private&gt; _compileAtom(nfa, parseTreeNode) Processes expressions in parenthesis and terminals Parameters: Name Type Description nfa prakalpa.parser.NFA The NFA representing the production rule parseTreeNode prakalpa.parser.ParseTreeNode The node that represents the start of the alternatives Source: parser/pgen.js, line 351 &lt;private&gt; _compileItem(nfa, parseTreeNode) Processes each item on the RHS. An item maybe another non terminal or an expression with or without repeat directives Parameters: Name Type Description nfa prakalpa.parser.NFA The NFA representing the production rule parseTreeNode prakalpa.parser.ParseTreeNode The node that represents the start of the alternatives Source: parser/pgen.js, line 299 &lt;private&gt; _compileRHS(nfa, parseTreeNode) Processes the right hand side of a grammar production rule Parameters: Name Type Description nfa prakalpa.parser.NFA The NFA representing the production rule parseTreeNode prakalpa.parser.ParseTreeNode The node that represents the start of the rhs Source: parser/pgen.js, line 221 &lt;private&gt; _compileRule(parseTreeNode) Processes a grammar production rule Parameters: Name Type Description parseTreeNode prakalpa.parser.ParseTreeNode The node that represents the start of the production rule Source: parser/pgen.js, line 186 &lt;private&gt; _makeDFAs() Create DFAs from the NFAs compiled from the CST Source: parser/pgen.js, line 89 &lt;private&gt; _metaCompile() Starts the compilation of the CST into NFAsSimilar to the algorithm given in 3.7.4 Construction of an NFA from a Regular Expression Source: parser/pgen.js, line 168 &lt;private&gt; _REQ(node, symbol) Asserts if the current node under processing is the expected one Parameters: Name Type Description node prakalpa.parser.ParseTreeNode Node under processing symbol String Name of symbol Source: parser/pgen.js, line 66 Throws: If the expectation is not met Type prakalpa.Exceptions.AssertionError &lt;private&gt; _REQN(children, expectedNumChildren) Asserts if the current node has the expected number of children Parameters: Name Type Description children Array.&lt;prakalpa.parser.ParseTreeNode&gt; Children of a node expectedNumChildren Number Expected number of children Source: parser/pgen.js, line 79 Throws: If the expectation is not met Type prakalpa.Exceptions.AssertionError &lt;private&gt; _translateLabels() Source: parser/pgen.js, line 105 Throws: If the NAME label is neither a terminal nor a non-terminal Type prakalpa.Exceptions.InvalidNameLabel If the one char label is not a valid one char token Type prakalpa.Exceptions.InvalidOneCharLabel If the two char label is not a valid two char token Type prakalpa.Exceptions.InvalidTwoCharLabel If the three char label is not a valid three char token Type prakalpa.Exceptions.InvalidThreeCharLabel × Search results Close "},"prakalpa.parser.ParseTreeNode.html":{"id":"prakalpa.parser.ParseTreeNode.html","title":"Class: ParseTreeNode","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: ParseTreeNode prakalpa.parser. ParseTreeNode new ParseTreeNode(symbol, string, lineNum, columnOffset) Parameters: Name Type Description symbol String Type of NonTerminal or Terminal string String Value of terminal lineNum Number Line number of terminal columnOffset Number Column offset of terminal Source: parser/parse_tree_node.js, line 5 Members children :Array.&lt;prakalpa.parser.ParseTreeNode&gt; Children of this node Type: Array.&lt;prakalpa.parser.ParseTreeNode&gt; Source: parser/parse_tree_node.js, line 15 string :String Value of terminal Type: String Source: parser/parse_tree_node.js, line 21 symbol :String Type of NonTerminal or Terminal Type: String Source: parser/parse_tree_node.js, line 26 Methods addChild(child) Adds a child to this node Parameters: Name Type Description child prakalpa.parser.ParseTreeNode The child you want to add Source: parser/parse_tree_node.js, line 37 is(symbol) Checks if the symbol for this node is the same as the given symbol Parameters: Name Type Description symbol String Source: parser/parse_tree_node.js, line 45 × Search results Close "},"prakalpa.parser.Stack.html":{"id":"prakalpa.parser.Stack.html","title":"Class: Stack","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: Stack prakalpa.parser. Stack new Stack() Source: parser/stack.js, line 4 Extends Array Methods isEmpty() Checks if stack is empty Source: parser/stack.js, line 30 Returns: Type Boolean peek( [String]) Get the value of the propertyName at the top of the stack if present, else return the top of the stack Parameters: Name Type Argument Description String &lt;optional&gt; propertyName Source: parser/stack.js, line 14 Returns: Value of property or object at the top of the stack Type Object updateTop(propertyName, newValue) Updates the the value of the property at the top of the stack Parameters: Name Type Description propertyName String Name of property you want to update newValue Object New value of the property Source: parser/stack.js, line 39 × Search results Close "},"prakalpa.Token.html":{"id":"prakalpa.Token.html","title":"Class: Token","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: Token prakalpa. Token new Token() Represents a token Properties: Name Type Description type prakalpa.constants.tokens Type of token start Object The position at which the token starts Properties Name Type Description column number The column number in a line at which the token starts lineNum number The line number in the source at which the token starts end Object The position just before which the token ends Properties Name Type Description column number The column number in a line before which the token ends lineNum number The line number in the source before which the token ends string string String value of token Source: token.js, line 5 × Search results Close "},"prakalpa.Tokenizer.html":{"id":"prakalpa.Tokenizer.html","title":"Class: Tokenizer","body":" Prakalpa Namespaces prakalpaprakalpa.parser Modules prakalpa.utilsprakalpa.parser.MetaGrammar Classes prakalpa.Exceptionsprakalpa.Exceptions.AssertionErrorprakalpa.Exceptions.InvalidNameLabelprakalpa.Exceptions.InvalidOneCharLabelprakalpa.Exceptions.InvalidThreeCharLabelprakalpa.Exceptions.InvalidTwoCharLabelprakalpa.Exceptions.LeftRecursionprakalpa.Exceptions.SyntaxErrorprakalpa.Exceptions.TokenizeErrorprakalpa.parser.DFAprakalpa.parser.DFAStateprakalpa.parser.NFAprakalpa.parser.Parserprakalpa.parser.ParserGeneratorprakalpa.parser.ParseTreeNodeprakalpa.parser.Stackprakalpa.Tokenprakalpa.Tokenizer Class: Tokenizer prakalpa. Tokenizer new Tokenizer(opts) The tokenizer splits a string into Python tokens Parameters: Name Type Description opts Properties Name Type Description sourceText String Source that needs to be tokenized Source: tokenizer.js, line 18 Methods &lt;private&gt; _again() Equivalent to the again label in cpython's tok_getProcesses newlines and the endmarker. Source: tokenizer.js, line 218 &lt;private&gt; _backupOneChar() Go back one character in the stream while accounting for newlines Source: tokenizer.js, line 104 &lt;private&gt; _countIndentsAndDedents() Matches indents and dedentsAlgorithm description taken from Tokens and Python's Lexical Structure Ensure that the first line has no indentation (0 white-space characters); if it does, report an error.If it doesn't, initialize the list with the value 0. For each logical line (after line–joining) If the current line’s indentation is &gt; the indentation at the list’s end Add the current line’s indentation to the end of the list. Produce an INDENT token. If the current line’s indentation is &lt; the indentation at the list’s end For each value at the end of the list that is unequal to the current line’sindentation (if it is not in the list, report a lexical error). Remove the value from the end of the list. Produce a DEDENT token. Tokenize the current line. For every indentation on the list except 0, produce a DEDENT token. Source: tokenizer.js, line 716 &lt;private&gt; _exponent() Processes an exponent token. Equivalent to the exponent label in cpython's tok_get Source: tokenizer.js, line 441 &lt;private&gt; _fraction() Processes a fraction token. Equivalent to the fraction label in cpython's tok_get Source: tokenizer.js, line 412 &lt;private&gt; _getNextChar() Get the next character in the stream and keep track of line number andcolumn number Source: tokenizer.js, line 89 Returns: nextChar - Next character in the source text Type String &lt;private&gt; _getString(start, end) Returns the value of the token starting at position start and endingjust before position end both columnwise and linewise Parameters: Name Type Description start Object The position at which the token starts Properties Name Type Description column Number The column number in a line at which the token starts lineNum Number The line number in the source at which the token starts end Object The position just before which the token ends Properties Name Type Description column Number The column number in a line before which the token ends lineNum Number The line number in the source before which the token ends Source: tokenizer.js, line 63 Returns: tokenString - String value of token starting at start and ending just before end Type String &lt;private&gt; _imaginary() Processes an imaginary token. Equivalent to the imaginary label in cpython's tok_get Source: tokenizer.js, line 488 &lt;private&gt; _isDigit() Checks if character is a decimal digit or not Source: tokenizer.js, line 770 &lt;private&gt; _isNumber() If the token is a number, processes that token, elsecalls the next processor in line Source: tokenizer.js, line 303 &lt;private&gt; _isPotentialIdentifierChar() Checks if the char is a valid identifier character Source: tokenizer.js, line 685 &lt;private&gt; _isPotentialIdentifierStart() Checks if the token begins with a valid identifier start character Source: tokenizer.js, line 669 &lt;private&gt; _isXDigit() Checks if character is a hexadecimal digit or not Source: tokenizer.js, line 782 &lt;private&gt; _letterQuote() If token is a string token, processes that token, elsecontinues to the next processor in line.Equivalent to the letter_quote label in cpython's tok_get Source: tokenizer.js, line 507 &lt;private&gt; _lineContinuation() If there's a line continuation in the source, processes thatand continues to the next processor in line. Source: tokenizer.js, line 580 &lt;private&gt; _nextline() Processes one line and keeps track of indents and dedents.Corresponds to the nextline goto label in cpython's tok_get function. Source: tokenizer.js, line 118 &lt;private&gt; _oneCharacter() Processes a one character token else continues to the next processor in line Source: tokenizer.js, line 652 &lt;private&gt; _parenthesesCheck() Matches braces, parenthesis and square brackets Source: tokenizer.js, line 631 &lt;private&gt; _processNames(c) Checks for an identifier which is the most frequent token Parameters: Name Type Description c String The next character in the source Source: tokenizer.js, line 163 &lt;private&gt; _startWithPeriod() If the token begins with a period, processes that token, elsecalls the next processor in line Source: tokenizer.js, line 262 &lt;private&gt; _twoCharacter() Processes a two character token else continues to the next processor in line Source: tokenizer.js, line 601 &lt;private&gt; _verifyIdentifier() Checks if an identifier is a proper unicode string PEP 3131 (TODO) Source: tokenizer.js, line 154 getNext() Entrypoint into the tokenizer. Returns the next token in the stream Source: tokenizer.js, line 47 Throws: Will throw an error if a syntax errors is encountered Type prakalpa.Exceptions.TokenizeError Returns: token - Next token Type prakalpa.Token × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
