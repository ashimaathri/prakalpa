<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Prakalpa Source: parser/pgen.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Prakalpa</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="prakalpa.html">prakalpa</a></li><li><a href="prakalpa.parser.html">prakalpa.parser</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="prakalpa.module_utils.html">prakalpa.utils</a></li><li><a href="prakalpa.parser.module_MetaGrammar.html">prakalpa.parser.MetaGrammar</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="prakalpa.Exceptions.html">prakalpa.Exceptions</a></li><li><a href="prakalpa.Exceptions.AssertionError.html">prakalpa.Exceptions.AssertionError</a></li><li><a href="prakalpa.Exceptions.InvalidNameLabel.html">prakalpa.Exceptions.InvalidNameLabel</a></li><li><a href="prakalpa.Exceptions.InvalidOneCharLabel.html">prakalpa.Exceptions.InvalidOneCharLabel</a></li><li><a href="prakalpa.Exceptions.InvalidThreeCharLabel.html">prakalpa.Exceptions.InvalidThreeCharLabel</a></li><li><a href="prakalpa.Exceptions.InvalidTwoCharLabel.html">prakalpa.Exceptions.InvalidTwoCharLabel</a></li><li><a href="prakalpa.Exceptions.LeftRecursion.html">prakalpa.Exceptions.LeftRecursion</a></li><li><a href="prakalpa.Exceptions.SyntaxError.html">prakalpa.Exceptions.SyntaxError</a></li><li><a href="prakalpa.Exceptions.TokenizeError.html">prakalpa.Exceptions.TokenizeError</a></li><li><a href="prakalpa.parser.DFA.html">prakalpa.parser.DFA</a></li><li><a href="prakalpa.parser.DFAState.html">prakalpa.parser.DFAState</a></li><li><a href="prakalpa.parser.NFA.html">prakalpa.parser.NFA</a></li><li><a href="prakalpa.parser.Parser.html">prakalpa.parser.Parser</a></li><li><a href="prakalpa.parser.ParserGenerator.html">prakalpa.parser.ParserGenerator</a></li><li><a href="prakalpa.parser.ParseTreeNode.html">prakalpa.parser.ParseTreeNode</a></li><li><a href="prakalpa.parser.Stack.html">prakalpa.parser.Stack</a></li><li><a href="prakalpa.Token.html">prakalpa.Token</a></li><li><a href="prakalpa.Tokenizer.html">prakalpa.Tokenizer</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: parser/pgen.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">define([
  'dojo/_base/declare',
  'dojo/_base/lang',
  'dojo/_base/array',
  'prakalpa/constants/non_terminals',
  'prakalpa/constants/tokens',
  'prakalpa/tokenizer',
  'prakalpa/parser/nfa',
  'prakalpa/parser/dfa',
  'prakalpa/exceptions',
  'prakalpa/utils'
], function (declare, lang, array, NonTerminals, Terminals, Tokenizer, NFA, DFA, Exceptions, Utils) {
  /**
    * Generates the Python Parser DFAs using the CST generated by parsing the Python Grammar using the MetaGrammar
    * @class prakalpa.parser.ParserGenerator
    * @param {Object} opts
    * @param {prakalpa.parser.ParseTreeNode} opts.parseTreeRoot - Root of CST generated by parsing the Python Grammar using the MetaGrammar
    */
  return declare([], /** @lends prakalpa.parser.ParserGenerator.prototype */{
    constructor: function (opts) {
      lang.mixin(this, opts);
      /**
        * The map containing all the Parser DFAs
        * @name prakalpa.parser.ParserGenerator#dfas
        * @type {Object.&lt;String, prakalpa.parser.DFA>}
        */
      this.dfas = {};
      /**
        * Contains all the tokens (type and string value) of the Python Language 
        * @name prakalpa.parser.ParserGenerator#labels
        * @type {Array&lt;Object>}
        */
      this.labels = [];
      this._nfas = {};

      this._metaCompile();
      this._makeDFAs();
      this._translateLabels();
      this._calcFirstSet();
    },

    /**
      * Adds a new label to the list if not already present
      * @private
      * @param {Object.&lt;String, String>} newLabel - type and string of the new label to be added
      */
    _addLabel: function (newLabel) {
      var existingLabel;

      existingLabel = array.filter(this.labels, function (label) {
        return (label.type === newLabel.type &amp;&amp; label.string === newLabel.string);
      });

      if(!existingLabel.length) {
        this.labels.push(newLabel);
      }
    },

    /**
      * Asserts if the current node under processing is the expected one
      * @private
      * @param {prakalpa.parser.ParseTreeNode} node - Node under processing
      * @param {String} symbol - Name of symbol
      * @throws {prakalpa.Exceptions.AssertionError} If the expectation is not met
      */
    _REQ: function (node, expectedSymbol) {
      if(!node.is(expectedSymbol)) {
        throw new Exceptions.AssertionError('Expected ' + expectedSymbol + ', got ' + node.symbol);
      }
    },

    /**
      * Asserts if the current node has the expected number of children
      * @private
      * @param {Array&lt;prakalpa.parser.ParseTreeNode>} children - Children of a node
      * @param {Number} expectedNumChildren - Expected number of children
      * @throws {prakalpa.Exceptions.AssertionError} If the expectation is not met
      */
    _REQN: function (children, expectedNumChildren) {
      if(children.length &lt; expectedNumChildren) {
        throw new Exceptions.AssertionError('Expected at least' + expectedNumChildren + ' children, got ' + children.length);
      }
    },

    /**
      * Create DFAs from the NFAs compiled from the CST
      * @private
      */
    _makeDFAs: function () {
      var nfa, type;

      for(type in this._nfas) {
        nfa = this._nfas[type];
        this.dfas[type] = new DFA({type: type, nfa: nfa});
      }
    },

    /**
      * @private
      * @throws {prakalpa.Exceptions.InvalidNameLabel} If the NAME label is neither a terminal nor a non-terminal
      * @throws {prakalpa.Exceptions.InvalidOneCharLabel} If the one char label is not a valid one char token
      * @throws {prakalpa.Exceptions.InvalidTwoCharLabel} If the two char label is not a valid two char token
      * @throws {prakalpa.Exceptions.InvalidThreeCharLabel} If the three char label is not a valid three char token
      */
    _translateLabels: function () {
      array.forEach(this.labels, function (label) {
        var keywordRegex, type;
        switch(label.type) {
          case Terminals.NAME:
            if(Utils.isNonTerminal(label.string, this.dfas) || Utils.isTerminal(label.string)) {
              label.type = label.string;
            } else {
              throw new Exceptions.InvalidNameLabel(label);
            }
            break;
          case Terminals.STRING:
            label.string = label.string.slice(1, -1);
            keywordRegex = /^[A-Za-z_]/;
            if(label.string.match(keywordRegex)) {
              label.type = Terminals.NAME;
            } else if(label.string.length === 1) {
              type = Utils.oneCharToken(label.string);
              if(type !== Terminals.OP) {
                label.type = type;
              } else {
                throw new Exceptions.InvalidOneCharLabel(label);
              }
            } else if(label.string.length === 2) {
              type = Utils.twoCharToken(label.string[0], label.string[1]);
              if(type !== Terminals.OP) {
                label.type = type;
              } else {
                throw new Exceptions.InvalidTwoCharLabel(label);
              }
            } else if(label.string.length === 3) {
              type = Utils.threeCharToken(label.string[0], label.string[1], label.string[2]);
              if(type !== Terminals.OP) {
                label.type = type;
              } else {
                throw new Exceptions.InvalidThreeCharLabel(label);
              }
            }
            break;
          default:
            // Don't do anything, the label is fine
        }
      }.bind(this));
    },

    /**
      * Calculates the first set of every dfa in the list
      * @private
      */
    _calcFirstSet: function () {
      var type, dfa;

      for(type in this.dfas) {
        dfa = this.dfas[type];
        dfa.calcFirstSet(this.dfas);
      }
    },

    /**
      * Starts the compilation of the CST into NFAs
      * Similar to the algorithm given in [3.7.4 Construction of an NFA from a Regular Expression](http://www.informatik.uni-bremen.de/agbkb/lehre/ccfl/Material/ALSUdragonbook.pdf) 
      * @private
      */
    _metaCompile: function () {
      var i, child;

      this._REQ(this.parseTreeRoot, NonTerminals.MSTART);
      // Process all children (RULES) other than the last child (ENDMARKER)
      for(i = 0; i &lt; this.parseTreeRoot.children.length - 1; i++) {
        child = this.parseTreeRoot.children[i];
        if(!child.is(Terminals.NEWLINE)) {
          this._compileRule(child);
        }
      }
    },

    /**
      * Processes a grammar production rule
      * @private
      * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the production rule
      */
    _compileRule: function (parseTreeNode) {
      var child, i, nfa, states, string;

      i = 0;

      this._REQ(parseTreeNode, NonTerminals.RULE);
      this._REQN(parseTreeNode.children, 4);

      child = parseTreeNode.children[i++];
      this._REQ(child, Terminals.NAME);

      string = child.string;
      this._addLabel({ type: Terminals.NAME, string: string });
      nfa = new NFA({ name: string });
      this._nfas[string] = nfa;

      child = parseTreeNode.children[i++];
      this._REQ(child, Terminals.COLON);

      child = parseTreeNode.children[i++];
      this._REQ(child, NonTerminals.RHS);
      states = this._compileRHS(nfa, child);
      nfa.setStart(states.start);
      nfa.setEnd(states.end);

      child = parseTreeNode.children[i];
      this._REQ(child, Terminals.NEWLINE);
    },

    /**
      * Processes the right hand side of a grammar production rule
      * @private
      * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule
      * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the rhs 
      */
    _compileRHS: function (nfa, parseTreeNode) {
      var child, i, newStart, newEnd, states, start, end;

      i = 0;

      this._REQ(parseTreeNode, NonTerminals.RHS);
      this._REQN(parseTreeNode.children, 1);

      child = parseTreeNode.children[i++];
      this._REQ(child, NonTerminals.ALT);

      states = this._compileAlt(nfa, child);
      start = states.start;
      end = states.end;

      if(i >= parseTreeNode.children.length) {
        return { start: start, end: end };
      }

      newStart = nfa.addNewState();
      newEnd = nfa.addNewState();
      nfa.addEmptyArc(newStart, start);
      nfa.addEmptyArc(end, newEnd);
      start = newStart;
      end = newEnd;

      for(; i &lt; parseTreeNode.children.length; i++) {
        child = parseTreeNode.children[i];
        this._REQ(child, Terminals.VBAR);
        this._REQN(parseTreeNode.children - i, 1);
        i++;
        child = parseTreeNode.children[i];
        this._REQ(child, NonTerminals.ALT);
        states = this._compileAlt(nfa, child);
        nfa.addEmptyArc(start, states.start);
        nfa.addEmptyArc(states.end, end);
      }

      return { start: start, end: end };
    },

    /**
      * Processes alternatives (options separated by a | character in the RHS of a production rule)
      * @private
      * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule
      * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the alternatives
      */
    _compileAlt: function (nfa, parseTreeNode) {
      var child, i, states, start, end;

      i = 0;

      this._REQ(parseTreeNode, NonTerminals.ALT);
      this._REQN(parseTreeNode.children, 1);

      child = parseTreeNode.children[i++];
      this._REQ(child, NonTerminals.ITEM);
      states = this._compileItem(nfa, child);
      start = states.start;
      end = states.end;

      for(; i &lt; parseTreeNode.children.length; i++) {
        child = parseTreeNode.children[i];
        this._REQ(child, NonTerminals.ITEM);
        states = this._compileItem(nfa, child);
        nfa.addEmptyArc(end, states.start);
        end = states.end;
      }

      return { start: start, end: end };
    },

    /**
      * Processes each item on the RHS. An item maybe another non terminal or an expression with or without repeat directives
      * @private
      * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule
      * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the alternatives
      */
    _compileItem: function (nfa, parseTreeNode) {
      var child, i, states, start, end;

      i = 0;

      this._REQ(parseTreeNode, NonTerminals.ITEM);
      this._REQN(parseTreeNode.children, 1);

      child = parseTreeNode.children[i++];

      if(child.is(Terminals.LSQB)) {
        this._REQN(parseTreeNode.children, 3);

        child = parseTreeNode.children[i++];
        this._REQ(child, NonTerminals.RHS);

        start = nfa.addNewState();
        end = nfa.addNewState();
        nfa.addEmptyArc(start, end);

        states = this._compileRHS(nfa, child);
        nfa.addEmptyArc(start, states.start);
        nfa.addEmptyArc(states.end, end);

        child = parseTreeNode.children[i];
        this._REQ(child, Terminals.RSQB);
      } else {
        states = this._compileAtom(nfa, child);
        start = states.start;
        end = states.end;
        if(i >= parseTreeNode.children.length) {
          return { start: start, end: end };
        }

        child = parseTreeNode.children[i];
        nfa.addEmptyArc(end, start);

        if(child.is(Terminals.STAR)) {
          end = start;
        } else {
          this._REQ(child, Terminals.PLUS);
        }
      }
      return { start: start, end: end };
    },

    /**
      * Processes expressions in parenthesis and terminals
      * @private
      * @param {prakalpa.parser.NFA} nfa - The NFA representing the production rule
      * @param {prakalpa.parser.ParseTreeNode} parseTreeNode - The node that represents the start of the alternatives
      */
    _compileAtom: function (nfa, parseTreeNode) {
      var child, i, states, start, end;

      i = 0;

      this._REQ(parseTreeNode, NonTerminals.ATOM);
      this._REQN(parseTreeNode.children, 1);

      child = parseTreeNode.children[i++];

      if(child.is(Terminals.LPAR)) {
        this._REQN(parseTreeNode.children, 3);

        child = parseTreeNode.children[i++];
        this._REQ(child, NonTerminals.RHS);
        states = this._compileRHS(nfa, child);
        start = states.start;
        end = states.end;

        child = parseTreeNode.children[i];
        this._REQ(child, Terminals.RPAR);
      } else if (child.is(Terminals.NAME) || child.is(Terminals.STRING)) {
        start = nfa.addNewState();
        end = nfa.addNewState();
        this._addLabel({ type: child.symbol, string: child.string });
        nfa.addArc(start, end, child.string);
      } else {
        this._REQ(child, Terminals.NAME);
      }

      return { start: start, end: end };
    }
  });
});
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright Â© 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.1</a>
	
		on Wed Sep 21st 2016
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
